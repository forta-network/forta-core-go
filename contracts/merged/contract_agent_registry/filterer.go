// Code generated by go-merge-types. DO NOT EDIT.

package contract_agent_registry

import (
	import_fmt "fmt"
	import_sync "sync"


	agentregistry014 "github.com/forta-network/forta-core-go/contracts/generated/contract_agent_registry_0_1_4"

	agentregistry016 "github.com/forta-network/forta-core-go/contracts/generated/contract_agent_registry_0_1_6"



	"github.com/ethereum/go-ethereum/accounts/abi/bind"

	"github.com/ethereum/go-ethereum/event"

	"github.com/ethereum/go-ethereum/core/types"

	"github.com/ethereum/go-ethereum/common"

	"math/big"

)

// AgentRegistryFilterer is a new type which can multiplex calls to different implementation types.
type AgentRegistryFilterer struct {

	typ0 *agentregistry014.AgentRegistryFilterer

	typ1 *agentregistry016.AgentRegistryFilterer

	currTag string
	mu import_sync.RWMutex
	unsafe bool // default: false
}

// NewAgentRegistryFilterer creates a new merged type.
func NewAgentRegistryFilterer(address common.Address, filterer bind.ContractFilterer) (*AgentRegistryFilterer, error) {
	var (
		mergedType AgentRegistryFilterer
		err error
	)
	mergedType.currTag = "0.1.4"


	mergedType.typ0, err = agentregistry014.NewAgentRegistryFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize agentregistry014.AgentRegistryFilterer: %v", err)
	}

	mergedType.typ1, err = agentregistry016.NewAgentRegistryFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize agentregistry016.AgentRegistryFilterer: %v", err)
	}


	return &mergedType, nil
}

// Use sets the used implementation to given tag.
func (merged *AgentRegistryFilterer) Use(tag string) (changed bool) {
	if !merged.unsafe {
		merged.mu.Lock()
		defer merged.mu.Unlock()
	}
	changed = merged.currTag != tag
	merged.currTag = tag
	return
}

// Unsafe disables the mutex.
func (merged *AgentRegistryFilterer) Unsafe() {
	merged.unsafe = true
}

// Safe enables the mutex.
func (merged *AgentRegistryFilterer) Safe() {
	merged.unsafe = false
}



// FilterAccessManagerUpdatedOutput is a merged return type.
type FilterAccessManagerUpdatedOutput struct {

	Agentregistry014Result *agentregistry014.AgentRegistryAccessManagerUpdatedIterator

	Agentregistry016Result *agentregistry016.AgentRegistryAccessManagerUpdatedIterator

}

// FilterAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) FilterAccessManagerUpdated(opts *bind.FilterOpts, newAddressManager []common.Address) (retVal *FilterAccessManagerUpdatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterAccessManagerUpdatedOutput{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.FilterAccessManagerUpdated(opts, newAddressManager)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry014Result = val


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.FilterAccessManagerUpdated(opts, newAddressManager)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry016Result = val


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.FilterAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) WatchAccessManagerUpdated(opts *bind.WatchOpts, sink chan<- *agentregistry014.AgentRegistryAccessManagerUpdated, newAddressManager []common.Address, sinkAlt1 chan<- *agentregistry016.AgentRegistryAccessManagerUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.WatchAccessManagerUpdated(opts, sink, newAddressManager)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.WatchAccessManagerUpdated(opts, sinkAlt1, newAddressManager)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.WatchAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// AccessManagerUpdatedEvent is a merged return type.
type AccessManagerUpdatedEvent struct {

	NewAddressManager common.Address

	Raw types.Log

}

// ParseAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) ParseAccessManagerUpdated(log types.Log) (retVal *AccessManagerUpdatedEvent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &AccessManagerUpdatedEvent{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.ParseAccessManagerUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.NewAddressManager = val.NewAddressManager

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.ParseAccessManagerUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.NewAddressManager = val.NewAddressManager

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.ParseAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// FilterAdminChangedOutput is a merged return type.
type FilterAdminChangedOutput struct {

	Agentregistry014Result *agentregistry014.AgentRegistryAdminChangedIterator

	Agentregistry016Result *agentregistry016.AgentRegistryAdminChangedIterator

}

// FilterAdminChanged multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) FilterAdminChanged(opts *bind.FilterOpts) (retVal *FilterAdminChangedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterAdminChangedOutput{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.FilterAdminChanged(opts)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry014Result = val


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.FilterAdminChanged(opts)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry016Result = val


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.FilterAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}



// WatchAdminChanged multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) WatchAdminChanged(opts *bind.WatchOpts, sink chan<- *agentregistry014.AgentRegistryAdminChanged, sinkAlt2 chan<- *agentregistry016.AgentRegistryAdminChanged) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.WatchAdminChanged(opts, sink)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.WatchAdminChanged(opts, sinkAlt2)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.WatchAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}


// AdminChangedEvent is a merged return type.
type AdminChangedEvent struct {

	PreviousAdmin common.Address

	NewAdmin common.Address

	Raw types.Log

}

// ParseAdminChanged multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) ParseAdminChanged(log types.Log) (retVal *AdminChangedEvent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &AdminChangedEvent{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.ParseAdminChanged(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.ParseAdminChanged(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.ParseAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}


// FilterAgentCommittedOutput is a merged return type.
type FilterAgentCommittedOutput struct {

	Agentregistry014Result *agentregistry014.AgentRegistryAgentCommittedIterator

	Agentregistry016Result *agentregistry016.AgentRegistryAgentCommittedIterator

}

// FilterAgentCommitted multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) FilterAgentCommitted(opts *bind.FilterOpts, commit [][32]byte) (retVal *FilterAgentCommittedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterAgentCommittedOutput{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.FilterAgentCommitted(opts, commit)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry014Result = val


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.FilterAgentCommitted(opts, commit)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry016Result = val


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.FilterAgentCommitted not implemented (tag=%s)", merged.currTag)
	return
}



// WatchAgentCommitted multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) WatchAgentCommitted(opts *bind.WatchOpts, sink chan<- *agentregistry014.AgentRegistryAgentCommitted, commit [][32]byte, sinkAlt3 chan<- *agentregistry016.AgentRegistryAgentCommitted) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.WatchAgentCommitted(opts, sink, commit)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.WatchAgentCommitted(opts, sinkAlt3, commit)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.WatchAgentCommitted not implemented (tag=%s)", merged.currTag)
	return
}


// AgentCommittedEvent is a merged return type.
type AgentCommittedEvent struct {

	Commit [32]byte

	Raw types.Log

}

// ParseAgentCommitted multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) ParseAgentCommitted(log types.Log) (retVal *AgentCommittedEvent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &AgentCommittedEvent{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.ParseAgentCommitted(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Commit = val.Commit

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.ParseAgentCommitted(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Commit = val.Commit

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.ParseAgentCommitted not implemented (tag=%s)", merged.currTag)
	return
}


// FilterAgentEnabledOutput is a merged return type.
type FilterAgentEnabledOutput struct {

	Agentregistry014Result *agentregistry014.AgentRegistryAgentEnabledIterator

	Agentregistry016Result *agentregistry016.AgentRegistryAgentEnabledIterator

}

// FilterAgentEnabled multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) FilterAgentEnabled(opts *bind.FilterOpts, agentId []*big.Int, enabled []bool) (retVal *FilterAgentEnabledOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterAgentEnabledOutput{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.FilterAgentEnabled(opts, agentId, enabled)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry014Result = val


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.FilterAgentEnabled(opts, agentId, enabled)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry016Result = val


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.FilterAgentEnabled not implemented (tag=%s)", merged.currTag)
	return
}



// WatchAgentEnabled multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) WatchAgentEnabled(opts *bind.WatchOpts, sink chan<- *agentregistry014.AgentRegistryAgentEnabled, agentId []*big.Int, enabled []bool, sinkAlt4 chan<- *agentregistry016.AgentRegistryAgentEnabled) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.WatchAgentEnabled(opts, sink, agentId, enabled)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.WatchAgentEnabled(opts, sinkAlt4, agentId, enabled)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.WatchAgentEnabled not implemented (tag=%s)", merged.currTag)
	return
}


// AgentEnabledEvent is a merged return type.
type AgentEnabledEvent struct {

	AgentId *big.Int

	Enabled bool

	Permission uint8

	Value bool

	Raw types.Log

}

// ParseAgentEnabled multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) ParseAgentEnabled(log types.Log) (retVal *AgentEnabledEvent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &AgentEnabledEvent{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.ParseAgentEnabled(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.AgentId = val.AgentId

		retVal.Enabled = val.Enabled

		retVal.Permission = val.Permission

		retVal.Value = val.Value

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.ParseAgentEnabled(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.AgentId = val.AgentId

		retVal.Enabled = val.Enabled

		retVal.Permission = val.Permission

		retVal.Value = val.Value

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.ParseAgentEnabled not implemented (tag=%s)", merged.currTag)
	return
}


// FilterAgentUpdatedOutput is a merged return type.
type FilterAgentUpdatedOutput struct {

	Agentregistry014Result *agentregistry014.AgentRegistryAgentUpdatedIterator

	Agentregistry016Result *agentregistry016.AgentRegistryAgentUpdatedIterator

}

// FilterAgentUpdated multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) FilterAgentUpdated(opts *bind.FilterOpts, agentId []*big.Int, by []common.Address) (retVal *FilterAgentUpdatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterAgentUpdatedOutput{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.FilterAgentUpdated(opts, agentId, by)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry014Result = val


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.FilterAgentUpdated(opts, agentId, by)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry016Result = val


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.FilterAgentUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchAgentUpdated multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) WatchAgentUpdated(opts *bind.WatchOpts, sink chan<- *agentregistry014.AgentRegistryAgentUpdated, agentId []*big.Int, by []common.Address, sinkAlt5 chan<- *agentregistry016.AgentRegistryAgentUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.WatchAgentUpdated(opts, sink, agentId, by)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.WatchAgentUpdated(opts, sinkAlt5, agentId, by)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.WatchAgentUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// AgentUpdatedEvent is a merged return type.
type AgentUpdatedEvent struct {

	AgentId *big.Int

	By common.Address

	Metadata string

	ChainIds []*big.Int

	Raw types.Log

}

// ParseAgentUpdated multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) ParseAgentUpdated(log types.Log) (retVal *AgentUpdatedEvent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &AgentUpdatedEvent{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.ParseAgentUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.AgentId = val.AgentId

		retVal.By = val.By

		retVal.Metadata = val.Metadata

		retVal.ChainIds = val.ChainIds

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.ParseAgentUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.AgentId = val.AgentId

		retVal.By = val.By

		retVal.Metadata = val.Metadata

		retVal.ChainIds = val.ChainIds

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.ParseAgentUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// FilterApprovalOutput is a merged return type.
type FilterApprovalOutput struct {

	Agentregistry014Result *agentregistry014.AgentRegistryApprovalIterator

	Agentregistry016Result *agentregistry016.AgentRegistryApprovalIterator

}

// FilterApproval multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (retVal *FilterApprovalOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterApprovalOutput{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.FilterApproval(opts, owner, approved, tokenId)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry014Result = val


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.FilterApproval(opts, owner, approved, tokenId)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry016Result = val


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.FilterApproval not implemented (tag=%s)", merged.currTag)
	return
}



// WatchApproval multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *agentregistry014.AgentRegistryApproval, owner []common.Address, approved []common.Address, tokenId []*big.Int, sinkAlt6 chan<- *agentregistry016.AgentRegistryApproval) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.WatchApproval(opts, sink, owner, approved, tokenId)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.WatchApproval(opts, sinkAlt6, owner, approved, tokenId)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.WatchApproval not implemented (tag=%s)", merged.currTag)
	return
}


// ApprovalEvent is a merged return type.
type ApprovalEvent struct {

	Owner common.Address

	Approved common.Address

	TokenId *big.Int

	Raw types.Log

}

// ParseApproval multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) ParseApproval(log types.Log) (retVal *ApprovalEvent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ApprovalEvent{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.ParseApproval(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Owner = val.Owner

		retVal.Approved = val.Approved

		retVal.TokenId = val.TokenId

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.ParseApproval(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Owner = val.Owner

		retVal.Approved = val.Approved

		retVal.TokenId = val.TokenId

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.ParseApproval not implemented (tag=%s)", merged.currTag)
	return
}


// FilterApprovalForAllOutput is a merged return type.
type FilterApprovalForAllOutput struct {

	Agentregistry014Result *agentregistry014.AgentRegistryApprovalForAllIterator

	Agentregistry016Result *agentregistry016.AgentRegistryApprovalForAllIterator

}

// FilterApprovalForAll multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (retVal *FilterApprovalForAllOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterApprovalForAllOutput{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.FilterApprovalForAll(opts, owner, operator)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry014Result = val


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.FilterApprovalForAll(opts, owner, operator)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry016Result = val


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.FilterApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}



// WatchApprovalForAll multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *agentregistry014.AgentRegistryApprovalForAll, owner []common.Address, operator []common.Address, sinkAlt7 chan<- *agentregistry016.AgentRegistryApprovalForAll) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.WatchApprovalForAll(opts, sink, owner, operator)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.WatchApprovalForAll(opts, sinkAlt7, owner, operator)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.WatchApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}


// ApprovalForAllEvent is a merged return type.
type ApprovalForAllEvent struct {

	Owner common.Address

	Operator common.Address

	Approved bool

	Raw types.Log

}

// ParseApprovalForAll multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) ParseApprovalForAll(log types.Log) (retVal *ApprovalForAllEvent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ApprovalForAllEvent{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.ParseApprovalForAll(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Owner = val.Owner

		retVal.Operator = val.Operator

		retVal.Approved = val.Approved

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.ParseApprovalForAll(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Owner = val.Owner

		retVal.Operator = val.Operator

		retVal.Approved = val.Approved

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.ParseApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}


// FilterBeaconUpgradedOutput is a merged return type.
type FilterBeaconUpgradedOutput struct {

	Agentregistry014Result *agentregistry014.AgentRegistryBeaconUpgradedIterator

	Agentregistry016Result *agentregistry016.AgentRegistryBeaconUpgradedIterator

}

// FilterBeaconUpgraded multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) FilterBeaconUpgraded(opts *bind.FilterOpts, beacon []common.Address) (retVal *FilterBeaconUpgradedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterBeaconUpgradedOutput{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.FilterBeaconUpgraded(opts, beacon)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry014Result = val


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.FilterBeaconUpgraded(opts, beacon)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry016Result = val


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.FilterBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// WatchBeaconUpgraded multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) WatchBeaconUpgraded(opts *bind.WatchOpts, sink chan<- *agentregistry014.AgentRegistryBeaconUpgraded, beacon []common.Address, sinkAlt8 chan<- *agentregistry016.AgentRegistryBeaconUpgraded) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.WatchBeaconUpgraded(opts, sink, beacon)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.WatchBeaconUpgraded(opts, sinkAlt8, beacon)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.WatchBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// BeaconUpgradedEvent is a merged return type.
type BeaconUpgradedEvent struct {

	Beacon common.Address

	Raw types.Log

}

// ParseBeaconUpgraded multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) ParseBeaconUpgraded(log types.Log) (retVal *BeaconUpgradedEvent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &BeaconUpgradedEvent{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.ParseBeaconUpgraded(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.ParseBeaconUpgraded(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.ParseBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// FilterFrontRunningDelaySetOutput is a merged return type.
type FilterFrontRunningDelaySetOutput struct {

	Agentregistry014Result *agentregistry014.AgentRegistryFrontRunningDelaySetIterator

	Agentregistry016Result *agentregistry016.AgentRegistryFrontRunningDelaySetIterator

}

// FilterFrontRunningDelaySet multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) FilterFrontRunningDelaySet(opts *bind.FilterOpts) (retVal *FilterFrontRunningDelaySetOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterFrontRunningDelaySetOutput{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.FilterFrontRunningDelaySet(opts)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry014Result = val


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.FilterFrontRunningDelaySet(opts)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry016Result = val


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.FilterFrontRunningDelaySet not implemented (tag=%s)", merged.currTag)
	return
}



// WatchFrontRunningDelaySet multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) WatchFrontRunningDelaySet(opts *bind.WatchOpts, sink chan<- *agentregistry014.AgentRegistryFrontRunningDelaySet, sinkAlt9 chan<- *agentregistry016.AgentRegistryFrontRunningDelaySet) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.WatchFrontRunningDelaySet(opts, sink)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.WatchFrontRunningDelaySet(opts, sinkAlt9)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.WatchFrontRunningDelaySet not implemented (tag=%s)", merged.currTag)
	return
}


// FrontRunningDelaySetEvent is a merged return type.
type FrontRunningDelaySetEvent struct {

	Delay *big.Int

	Raw types.Log

}

// ParseFrontRunningDelaySet multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) ParseFrontRunningDelaySet(log types.Log) (retVal *FrontRunningDelaySetEvent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FrontRunningDelaySetEvent{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.ParseFrontRunningDelaySet(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Delay = val.Delay

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.ParseFrontRunningDelaySet(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Delay = val.Delay

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.ParseFrontRunningDelaySet not implemented (tag=%s)", merged.currTag)
	return
}


// FilterInitializedOutput is a merged return type.
type FilterInitializedOutput struct {

	Agentregistry014Result *agentregistry014.AgentRegistryInitializedIterator

	Agentregistry016Result *agentregistry016.AgentRegistryInitializedIterator

}

// FilterInitialized multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) FilterInitialized(opts *bind.FilterOpts) (retVal *FilterInitializedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterInitializedOutput{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.FilterInitialized(opts)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry014Result = val


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.FilterInitialized(opts)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry016Result = val


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.FilterInitialized not implemented (tag=%s)", merged.currTag)
	return
}



// WatchInitialized multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *agentregistry014.AgentRegistryInitialized, sinkAlt10 chan<- *agentregistry016.AgentRegistryInitialized) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.WatchInitialized(opts, sink)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.WatchInitialized(opts, sinkAlt10)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.WatchInitialized not implemented (tag=%s)", merged.currTag)
	return
}


// InitializedEvent is a merged return type.
type InitializedEvent struct {

	Version uint8

	Raw types.Log

}

// ParseInitialized multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) ParseInitialized(log types.Log) (retVal *InitializedEvent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &InitializedEvent{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.ParseInitialized(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Version = val.Version

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.ParseInitialized(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Version = val.Version

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.ParseInitialized not implemented (tag=%s)", merged.currTag)
	return
}


// FilterRouterUpdatedOutput is a merged return type.
type FilterRouterUpdatedOutput struct {

	Agentregistry014Result *agentregistry014.AgentRegistryRouterUpdatedIterator

	Agentregistry016Result *agentregistry016.AgentRegistryRouterUpdatedIterator

}

// FilterRouterUpdated multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) FilterRouterUpdated(opts *bind.FilterOpts, router []common.Address) (retVal *FilterRouterUpdatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterRouterUpdatedOutput{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.FilterRouterUpdated(opts, router)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry014Result = val


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.FilterRouterUpdated(opts, router)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry016Result = val


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.FilterRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchRouterUpdated multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) WatchRouterUpdated(opts *bind.WatchOpts, sink chan<- *agentregistry014.AgentRegistryRouterUpdated, router []common.Address, sinkAlt11 chan<- *agentregistry016.AgentRegistryRouterUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.WatchRouterUpdated(opts, sink, router)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.WatchRouterUpdated(opts, sinkAlt11, router)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.WatchRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// RouterUpdatedEvent is a merged return type.
type RouterUpdatedEvent struct {

	Router common.Address

	Raw types.Log

}

// ParseRouterUpdated multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) ParseRouterUpdated(log types.Log) (retVal *RouterUpdatedEvent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &RouterUpdatedEvent{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.ParseRouterUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Router = val.Router

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.ParseRouterUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Router = val.Router

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.ParseRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// FilterStakeControllerUpdated multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) FilterStakeControllerUpdated(opts *bind.FilterOpts, newstakeController []common.Address) (retVal *agentregistry014.AgentRegistryStakeControllerUpdatedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.FilterStakeControllerUpdated(opts, newstakeController)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.FilterStakeControllerUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchStakeControllerUpdated multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) WatchStakeControllerUpdated(opts *bind.WatchOpts, sink chan<- *agentregistry014.AgentRegistryStakeControllerUpdated, newstakeController []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.WatchStakeControllerUpdated(opts, sink, newstakeController)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.WatchStakeControllerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// StakeControllerUpdatedEvent is a merged return type.
type StakeControllerUpdatedEvent struct {

	NewstakeController common.Address

	Raw types.Log

}

// ParseStakeControllerUpdated multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) ParseStakeControllerUpdated(log types.Log) (retVal *StakeControllerUpdatedEvent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &StakeControllerUpdatedEvent{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.ParseStakeControllerUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.NewstakeController = val.NewstakeController

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.ParseStakeControllerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// FilterStakeThresholdChangedOutput is a merged return type.
type FilterStakeThresholdChangedOutput struct {

	Agentregistry014Result *agentregistry014.AgentRegistryStakeThresholdChangedIterator

	Agentregistry016Result *agentregistry016.AgentRegistryStakeThresholdChangedIterator

}

// FilterStakeThresholdChanged multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) FilterStakeThresholdChanged(opts *bind.FilterOpts) (retVal *FilterStakeThresholdChangedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterStakeThresholdChangedOutput{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.FilterStakeThresholdChanged(opts)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry014Result = val


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.FilterStakeThresholdChanged(opts)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry016Result = val


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.FilterStakeThresholdChanged not implemented (tag=%s)", merged.currTag)
	return
}



// WatchStakeThresholdChanged multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) WatchStakeThresholdChanged(opts *bind.WatchOpts, sink chan<- *agentregistry014.AgentRegistryStakeThresholdChanged, sinkAlt12 chan<- *agentregistry016.AgentRegistryStakeThresholdChanged) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.WatchStakeThresholdChanged(opts, sink)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.WatchStakeThresholdChanged(opts, sinkAlt12)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.WatchStakeThresholdChanged not implemented (tag=%s)", merged.currTag)
	return
}


// StakeThresholdChangedEvent is a merged return type.
type StakeThresholdChangedEvent struct {

	Min *big.Int

	Max *big.Int

	Activated bool

	Raw types.Log

}

// ParseStakeThresholdChanged multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) ParseStakeThresholdChanged(log types.Log) (retVal *StakeThresholdChangedEvent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &StakeThresholdChangedEvent{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.ParseStakeThresholdChanged(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Min = val.Min

		retVal.Max = val.Max

		retVal.Activated = val.Activated

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.ParseStakeThresholdChanged(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Min = val.Min

		retVal.Max = val.Max

		retVal.Activated = val.Activated

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.ParseStakeThresholdChanged not implemented (tag=%s)", merged.currTag)
	return
}


// FilterTransferOutput is a merged return type.
type FilterTransferOutput struct {

	Agentregistry014Result *agentregistry014.AgentRegistryTransferIterator

	Agentregistry016Result *agentregistry016.AgentRegistryTransferIterator

}

// FilterTransfer multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (retVal *FilterTransferOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterTransferOutput{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.FilterTransfer(opts, from, to, tokenId)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry014Result = val


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.FilterTransfer(opts, from, to, tokenId)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry016Result = val


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.FilterTransfer not implemented (tag=%s)", merged.currTag)
	return
}



// WatchTransfer multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *agentregistry014.AgentRegistryTransfer, from []common.Address, to []common.Address, tokenId []*big.Int, sinkAlt13 chan<- *agentregistry016.AgentRegistryTransfer) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.WatchTransfer(opts, sink, from, to, tokenId)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.WatchTransfer(opts, sinkAlt13, from, to, tokenId)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.WatchTransfer not implemented (tag=%s)", merged.currTag)
	return
}


// TransferEvent is a merged return type.
type TransferEvent struct {

	From common.Address

	To common.Address

	TokenId *big.Int

	Raw types.Log

}

// ParseTransfer multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) ParseTransfer(log types.Log) (retVal *TransferEvent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &TransferEvent{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.ParseTransfer(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.From = val.From

		retVal.To = val.To

		retVal.TokenId = val.TokenId

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.ParseTransfer(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.From = val.From

		retVal.To = val.To

		retVal.TokenId = val.TokenId

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.ParseTransfer not implemented (tag=%s)", merged.currTag)
	return
}


// FilterUpgradedOutput is a merged return type.
type FilterUpgradedOutput struct {

	Agentregistry014Result *agentregistry014.AgentRegistryUpgradedIterator

	Agentregistry016Result *agentregistry016.AgentRegistryUpgradedIterator

}

// FilterUpgraded multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) FilterUpgraded(opts *bind.FilterOpts, implementation []common.Address) (retVal *FilterUpgradedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterUpgradedOutput{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.FilterUpgraded(opts, implementation)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry014Result = val


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.FilterUpgraded(opts, implementation)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Agentregistry016Result = val


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.FilterUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// WatchUpgraded multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) WatchUpgraded(opts *bind.WatchOpts, sink chan<- *agentregistry014.AgentRegistryUpgraded, implementation []common.Address, sinkAlt14 chan<- *agentregistry016.AgentRegistryUpgraded) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.WatchUpgraded(opts, sink, implementation)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.WatchUpgraded(opts, sinkAlt14, implementation)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.WatchUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// UpgradedEvent is a merged return type.
type UpgradedEvent struct {

	Implementation common.Address

	Raw types.Log

}

// ParseUpgraded multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) ParseUpgraded(log types.Log) (retVal *UpgradedEvent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &UpgradedEvent{}



	if merged.currTag == "0.1.4" {
	val, methodErr := merged.typ0.ParseUpgraded(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.ParseUpgraded(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.ParseUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// FilterSubjectHandlerUpdated multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) FilterSubjectHandlerUpdated(opts *bind.FilterOpts, newHandler []common.Address) (retVal *agentregistry016.AgentRegistrySubjectHandlerUpdatedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.FilterSubjectHandlerUpdated(opts, newHandler)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.FilterSubjectHandlerUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchSubjectHandlerUpdated multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) WatchSubjectHandlerUpdated(opts *bind.WatchOpts, sink chan<- *agentregistry016.AgentRegistrySubjectHandlerUpdated, newHandler []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.WatchSubjectHandlerUpdated(opts, sink, newHandler)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.WatchSubjectHandlerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// SubjectHandlerUpdatedEvent is a merged return type.
type SubjectHandlerUpdatedEvent struct {

	NewHandler common.Address

	Raw types.Log

}

// ParseSubjectHandlerUpdated multiplexes to different implementations of the method.
func (merged *AgentRegistryFilterer) ParseSubjectHandlerUpdated(log types.Log) (retVal *SubjectHandlerUpdatedEvent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &SubjectHandlerUpdatedEvent{}



	if merged.currTag == "0.1.6" {
	val, methodErr := merged.typ1.ParseSubjectHandlerUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.NewHandler = val.NewHandler

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("AgentRegistryFilterer.ParseSubjectHandlerUpdated not implemented (tag=%s)", merged.currTag)
	return
}