// Code generated by go-merge-types. DO NOT EDIT.

package contract_agent_registry

import (
	import_fmt "fmt"
	import_sync "sync"

	agentregistry014 "github.com/forta-network/forta-core-go/contracts/generated/contract_agent_registry_0_1_4"

	agentregistry016 "github.com/forta-network/forta-core-go/contracts/generated/contract_agent_registry_0_1_6"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"

	"github.com/ethereum/go-ethereum/common"

	"math/big"

	"github.com/ethereum/go-ethereum/core/types"
)

// AgentRegistryTransactor is a new type which can multiplex calls to different implementation types.
type AgentRegistryTransactor struct {
	typ0 *agentregistry014.AgentRegistryTransactor

	typ1 *agentregistry016.AgentRegistryTransactor

	currTag string
	mu      import_sync.RWMutex
	unsafe  bool // default: false
}

// NewAgentRegistryTransactor creates a new merged type.
func NewAgentRegistryTransactor(address common.Address, transactor bind.ContractTransactor) (*AgentRegistryTransactor, error) {
	var (
		mergedType AgentRegistryTransactor
		err        error
	)
	mergedType.currTag = "0.1.6"

	mergedType.typ0, err = agentregistry014.NewAgentRegistryTransactor(address, transactor)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize agentregistry014.AgentRegistryTransactor: %v", err)
	}

	mergedType.typ1, err = agentregistry016.NewAgentRegistryTransactor(address, transactor)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize agentregistry016.AgentRegistryTransactor: %v", err)
	}

	return &mergedType, nil
}

// IsKnownTagForAgentRegistryTransactor tells if given tag is a known tag.
func IsKnownTagForAgentRegistryTransactor(tag string) bool {

	if tag == "0.1.4" {
		return true
	}

	if tag == "0.1.6" {
		return true
	}

	return false
}

// Use sets the used implementation to given tag.
func (merged *AgentRegistryTransactor) Use(tag string) (changed bool) {
	if !merged.unsafe {
		merged.mu.Lock()
		defer merged.mu.Unlock()
	}
	// use the default tag if the provided tag is unknown
	if !IsKnownTagForAgentRegistryTransactor(tag) {
		tag = "0.1.6"
	}
	changed = merged.currTag != tag
	merged.currTag = tag
	return
}

// Unsafe disables the mutex.
func (merged *AgentRegistryTransactor) Unsafe() {
	merged.unsafe = true
}

// Safe enables the mutex.
func (merged *AgentRegistryTransactor) Safe() {
	merged.unsafe = false
}

// Approve multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) Approve(opts *bind.TransactOpts, to common.Address, tokenId *big.Int) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.Approve(opts, to, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.Approve(opts, to, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.Approve not implemented (tag=%s)", merged.currTag)
	return
}

// CreateAgent multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) CreateAgent(opts *bind.TransactOpts, agentId *big.Int, owner common.Address, metadata string, chainIds []*big.Int, arg1 common.Address) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.CreateAgent(opts, agentId, owner, metadata, chainIds)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.CreateAgent(opts, agentId, arg1, metadata, chainIds)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.CreateAgent not implemented (tag=%s)", merged.currTag)
	return
}

// DisableAgent multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) DisableAgent(opts *bind.TransactOpts, agentId *big.Int, permission uint8) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.DisableAgent(opts, agentId, permission)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.DisableAgent(opts, agentId, permission)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.DisableAgent not implemented (tag=%s)", merged.currTag)
	return
}

// EnableAgent multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) EnableAgent(opts *bind.TransactOpts, agentId *big.Int, permission uint8) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.EnableAgent(opts, agentId, permission)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.EnableAgent(opts, agentId, permission)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.EnableAgent not implemented (tag=%s)", merged.currTag)
	return
}

// Initialize multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) Initialize(opts *bind.TransactOpts, __manager common.Address, __router common.Address, __name string, __symbol string) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.Initialize(opts, __manager, __router, __name, __symbol)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.Initialize(opts, __manager, __name, __symbol)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.Initialize not implemented (tag=%s)", merged.currTag)
	return
}

// Multicall multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) Multicall(opts *bind.TransactOpts, data [][]byte) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.Multicall(opts, data)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.Multicall(opts, data)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.Multicall not implemented (tag=%s)", merged.currTag)
	return
}

// PrepareAgent multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) PrepareAgent(opts *bind.TransactOpts, commit [32]byte) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.PrepareAgent(opts, commit)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.PrepareAgent(opts, commit)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.PrepareAgent not implemented (tag=%s)", merged.currTag)
	return
}

// SafeTransferFrom multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.SafeTransferFrom(opts, from, to, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.SafeTransferFrom(opts, from, to, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.SafeTransferFrom not implemented (tag=%s)", merged.currTag)
	return
}

// SafeTransferFrom0 multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) SafeTransferFrom0(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int, data []byte) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.SafeTransferFrom0(opts, from, to, tokenId, data)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.SafeTransferFrom0(opts, from, to, tokenId, data)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.SafeTransferFrom0 not implemented (tag=%s)", merged.currTag)
	return
}

// SetAccessManager multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) SetAccessManager(opts *bind.TransactOpts, newManager common.Address) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.SetAccessManager(opts, newManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.SetAccessManager(opts, newManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.SetAccessManager not implemented (tag=%s)", merged.currTag)
	return
}

// SetApprovalForAll multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.SetApprovalForAll(opts, operator, approved)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.SetApprovalForAll(opts, operator, approved)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.SetApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}

// SetFrontRunningDelay multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) SetFrontRunningDelay(opts *bind.TransactOpts, delay *big.Int) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.SetFrontRunningDelay(opts, delay)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.SetFrontRunningDelay(opts, delay)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.SetFrontRunningDelay not implemented (tag=%s)", merged.currTag)
	return
}

// SetName multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) SetName(opts *bind.TransactOpts, ensRegistry common.Address, ensName string) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.SetName(opts, ensRegistry, ensName)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.SetName(opts, ensRegistry, ensName)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.SetName not implemented (tag=%s)", merged.currTag)
	return
}

// SetRouter multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) SetRouter(opts *bind.TransactOpts, newRouter common.Address) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.SetRouter(opts, newRouter)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.SetRouter not implemented (tag=%s)", merged.currTag)
	return
}

// SetStakeController multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) SetStakeController(opts *bind.TransactOpts, stakeController common.Address) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.SetStakeController(opts, stakeController)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.SetStakeController not implemented (tag=%s)", merged.currTag)
	return
}

// SetStakeThreshold multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) SetStakeThreshold(opts *bind.TransactOpts, newStakeThreshold agentregistry014.IStakeSubjectStakeThreshold, newStakeThresholdAlt1 agentregistry016.IStakeSubjectStakeThreshold) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.SetStakeThreshold(opts, newStakeThreshold)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.SetStakeThreshold(opts, newStakeThresholdAlt1)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.SetStakeThreshold not implemented (tag=%s)", merged.currTag)
	return
}

// TransferFrom multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.TransferFrom(opts, from, to, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.TransferFrom(opts, from, to, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.TransferFrom not implemented (tag=%s)", merged.currTag)
	return
}

// UpdateAgent multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) UpdateAgent(opts *bind.TransactOpts, agentId *big.Int, metadata string, chainIds []*big.Int) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.UpdateAgent(opts, agentId, metadata, chainIds)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.UpdateAgent(opts, agentId, metadata, chainIds)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.UpdateAgent not implemented (tag=%s)", merged.currTag)
	return
}

// UpgradeTo multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) UpgradeTo(opts *bind.TransactOpts, newImplementation common.Address) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.UpgradeTo(opts, newImplementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.UpgradeTo(opts, newImplementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.UpgradeTo not implemented (tag=%s)", merged.currTag)
	return
}

// UpgradeToAndCall multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) UpgradeToAndCall(opts *bind.TransactOpts, newImplementation common.Address, data []byte) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.UpgradeToAndCall(opts, newImplementation, data)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.UpgradeToAndCall(opts, newImplementation, data)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.UpgradeToAndCall not implemented (tag=%s)", merged.currTag)
	return
}

// DisableRouter multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) DisableRouter(opts *bind.TransactOpts) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.DisableRouter(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.DisableRouter not implemented (tag=%s)", merged.currTag)
	return
}

// RegisterAgent multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) RegisterAgent(opts *bind.TransactOpts, agentId *big.Int, metadata string, chainIds []*big.Int) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.RegisterAgent(opts, agentId, metadata, chainIds)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.RegisterAgent not implemented (tag=%s)", merged.currTag)
	return
}

// SetSubjectHandler multiplexes to different implementations of the method.
func (merged *AgentRegistryTransactor) SetSubjectHandler(opts *bind.TransactOpts, subjectGateway common.Address) (retVal *types.Transaction, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.SetSubjectHandler(opts, subjectGateway)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("AgentRegistryTransactor.SetSubjectHandler not implemented (tag=%s)", merged.currTag)
	return
}
