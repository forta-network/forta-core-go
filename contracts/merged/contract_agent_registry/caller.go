// Code generated by go-merge-types. DO NOT EDIT.

package contract_agent_registry

import (
	import_fmt "fmt"
	import_sync "sync"


	agentregistry014 "github.com/forta-network/forta-core-go/contracts/generated/contract_agent_registry_0_1_4"

	agentregistry016 "github.com/forta-network/forta-core-go/contracts/generated/contract_agent_registry_0_1_6"



	"github.com/ethereum/go-ethereum/accounts/abi/bind"

	"github.com/ethereum/go-ethereum/common"

	"math/big"

)

// AgentRegistryCaller is a new type which can multiplex calls to different implementation types.
type AgentRegistryCaller struct {

	typ0 *agentregistry014.AgentRegistryCaller

	typ1 *agentregistry016.AgentRegistryCaller

	currTag string
	mu import_sync.RWMutex
	unsafe bool // default: false
}

// NewAgentRegistryCaller creates a new merged type.
func NewAgentRegistryCaller(address common.Address, caller bind.ContractCaller) (*AgentRegistryCaller, error) {
	var (
		mergedType AgentRegistryCaller
		err error
	)
	mergedType.currTag = "0.1.6"


	mergedType.typ0, err = agentregistry014.NewAgentRegistryCaller(address, caller)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize agentregistry014.AgentRegistryCaller: %v", err)
	}

	mergedType.typ1, err = agentregistry016.NewAgentRegistryCaller(address, caller)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize agentregistry016.AgentRegistryCaller: %v", err)
	}


	return &mergedType, nil
}

// IsKnownTagForAgentRegistryCaller tells if given tag is a known tag.
func IsKnownTagForAgentRegistryCaller(tag string) bool {

	if tag == "0.1.4" {
		return true
	}

	if tag == "0.1.6" {
		return true
	}

	return false
}

// Use sets the used implementation to given tag.
func (merged *AgentRegistryCaller) Use(tag string) (changed bool) {
	if !merged.unsafe {
		merged.mu.Lock()
		defer merged.mu.Unlock()
	}
	// use the default tag if the provided tag is unknown
	if !IsKnownTagForAgentRegistryCaller(tag) {
		tag = "0.1.6"
	}
	changed = merged.currTag != tag
	merged.currTag = tag
	return
}

// Unsafe disables the mutex.
func (merged *AgentRegistryCaller) Unsafe() {
	merged.unsafe = true
}

// Safe enables the mutex.
func (merged *AgentRegistryCaller) Safe() {
	merged.unsafe = false
}




// BalanceOf multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) BalanceOf(opts *bind.CallOpts, owner common.Address) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.BalanceOf(opts, owner)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.BalanceOf(opts, owner)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.BalanceOf not implemented (tag=%s)", merged.currTag)
	return
}



// FrontRunningDelay multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) FrontRunningDelay(opts *bind.CallOpts) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.FrontRunningDelay(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.FrontRunningDelay(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.FrontRunningDelay not implemented (tag=%s)", merged.currTag)
	return
}


// GetAgentOutput is a merged return type.
type GetAgentOutput struct {

	Registered bool

	Owner common.Address

	AgentVersion *big.Int

	Metadata string

	ChainIds []*big.Int

}

// GetAgent multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) GetAgent(opts *bind.CallOpts, agentId *big.Int) (retVal *GetAgentOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &GetAgentOutput{}



	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.GetAgent(opts, agentId)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Registered = val.Registered

		retVal.Owner = val.Owner

		retVal.AgentVersion = val.AgentVersion

		retVal.Metadata = val.Metadata

		retVal.ChainIds = val.ChainIds


		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.GetAgent(opts, agentId)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Registered = val.Registered

		retVal.Owner = val.Owner

		retVal.AgentVersion = val.AgentVersion

		retVal.Metadata = val.Metadata

		retVal.ChainIds = val.ChainIds


		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.GetAgent not implemented (tag=%s)", merged.currTag)
	return
}



// GetAgentByChainAndIndex multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) GetAgentByChainAndIndex(opts *bind.CallOpts, chainId *big.Int, index *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.GetAgentByChainAndIndex(opts, chainId, index)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.GetAgentByChainAndIndex(opts, chainId, index)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.GetAgentByChainAndIndex not implemented (tag=%s)", merged.currTag)
	return
}



// GetAgentByIndex multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) GetAgentByIndex(opts *bind.CallOpts, index *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.GetAgentByIndex(opts, index)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.GetAgentByIndex(opts, index)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.GetAgentByIndex not implemented (tag=%s)", merged.currTag)
	return
}



// GetAgentCount multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) GetAgentCount(opts *bind.CallOpts) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.GetAgentCount(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.GetAgentCount(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.GetAgentCount not implemented (tag=%s)", merged.currTag)
	return
}



// GetAgentCountByChain multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) GetAgentCountByChain(opts *bind.CallOpts, chainId *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.GetAgentCountByChain(opts, chainId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.GetAgentCountByChain(opts, chainId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.GetAgentCountByChain not implemented (tag=%s)", merged.currTag)
	return
}


// GetAgentStateOutput is a merged return type.
type GetAgentStateOutput struct {

	Registered bool

	Owner common.Address

	AgentVersion *big.Int

	Metadata string

	ChainIds []*big.Int

	Enabled bool

	DisabledFlags *big.Int

}

// GetAgentState multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) GetAgentState(opts *bind.CallOpts, agentId *big.Int) (retVal *GetAgentStateOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &GetAgentStateOutput{}



	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.GetAgentState(opts, agentId)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Registered = val.Registered

		retVal.Owner = val.Owner

		retVal.AgentVersion = val.AgentVersion

		retVal.Metadata = val.Metadata

		retVal.ChainIds = val.ChainIds

		retVal.Enabled = val.Enabled

		retVal.DisabledFlags = val.DisabledFlags


		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.GetAgentState(opts, agentId)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Registered = val.Registered

		retVal.Owner = val.Owner

		retVal.AgentVersion = val.AgentVersion

		retVal.Metadata = val.Metadata

		retVal.ChainIds = val.ChainIds

		retVal.Enabled = val.Enabled

		retVal.DisabledFlags = val.DisabledFlags


		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.GetAgentState not implemented (tag=%s)", merged.currTag)
	return
}



// GetApproved multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.GetApproved(opts, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.GetApproved(opts, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.GetApproved not implemented (tag=%s)", merged.currTag)
	return
}



// GetCommitTimestamp multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) GetCommitTimestamp(opts *bind.CallOpts, commit [32]byte) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.GetCommitTimestamp(opts, commit)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.GetCommitTimestamp(opts, commit)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.GetCommitTimestamp not implemented (tag=%s)", merged.currTag)
	return
}



// GetDisableFlags multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) GetDisableFlags(opts *bind.CallOpts, agentId *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.GetDisableFlags(opts, agentId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.GetDisableFlags(opts, agentId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.GetDisableFlags not implemented (tag=%s)", merged.currTag)
	return
}



// GetStakeController multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) GetStakeController(opts *bind.CallOpts) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.GetStakeController(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.GetStakeController not implemented (tag=%s)", merged.currTag)
	return
}


// GetStakeThresholdOutput is a merged return type.
type GetStakeThresholdOutput struct {

	Min *big.Int

	Max *big.Int

	Activated bool

}

// GetStakeThreshold multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) GetStakeThreshold(opts *bind.CallOpts, arg0 *big.Int) (retVal *GetStakeThresholdOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &GetStakeThresholdOutput{}



	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.GetStakeThreshold(opts, arg0)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Min = val.Min

		retVal.Max = val.Max

		retVal.Activated = val.Activated


		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.GetStakeThreshold(opts, arg0)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Min = val.Min

		retVal.Max = val.Max

		retVal.Activated = val.Activated


		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.GetStakeThreshold not implemented (tag=%s)", merged.currTag)
	return
}



// IsApprovedForAll multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.IsApprovedForAll(opts, owner, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.IsApprovedForAll(opts, owner, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.IsApprovedForAll not implemented (tag=%s)", merged.currTag)
	return
}



// IsEnabled multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) IsEnabled(opts *bind.CallOpts, agentId *big.Int) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.IsEnabled(opts, agentId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.IsEnabled(opts, agentId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.IsEnabled not implemented (tag=%s)", merged.currTag)
	return
}



// IsRegistered multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) IsRegistered(opts *bind.CallOpts, agentId *big.Int) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.IsRegistered(opts, agentId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.IsRegistered(opts, agentId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.IsRegistered not implemented (tag=%s)", merged.currTag)
	return
}



// IsStakedOverMin multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) IsStakedOverMin(opts *bind.CallOpts, subject *big.Int) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.IsStakedOverMin(opts, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.IsStakedOverMin(opts, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.IsStakedOverMin not implemented (tag=%s)", merged.currTag)
	return
}



// IsTrustedForwarder multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) IsTrustedForwarder(opts *bind.CallOpts, forwarder common.Address) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.IsTrustedForwarder(opts, forwarder)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.IsTrustedForwarder not implemented (tag=%s)", merged.currTag)
	return
}



// Name multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) Name(opts *bind.CallOpts) (retVal string, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.Name(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.Name(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.Name not implemented (tag=%s)", merged.currTag)
	return
}



// OwnerOf multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) OwnerOf(opts *bind.CallOpts, tokenId *big.Int, subject *big.Int) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.OwnerOf(opts, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.OwnerOf(opts, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.OwnerOf not implemented (tag=%s)", merged.currTag)
	return
}



// ProxiableUUID multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) ProxiableUUID(opts *bind.CallOpts) (retVal [32]byte, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.ProxiableUUID(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.ProxiableUUID(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.ProxiableUUID not implemented (tag=%s)", merged.currTag)
	return
}



// SupportsInterface multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.SupportsInterface(opts, interfaceId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.SupportsInterface(opts, interfaceId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.SupportsInterface not implemented (tag=%s)", merged.currTag)
	return
}



// Symbol multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) Symbol(opts *bind.CallOpts) (retVal string, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.Symbol(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.Symbol(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.Symbol not implemented (tag=%s)", merged.currTag)
	return
}



// TokenURI multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) TokenURI(opts *bind.CallOpts, tokenId *big.Int) (retVal string, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.TokenURI(opts, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.TokenURI(opts, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.TokenURI not implemented (tag=%s)", merged.currTag)
	return
}



// Version multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) Version(opts *bind.CallOpts) (retVal string, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ0.Version(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.Version(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.Version not implemented (tag=%s)", merged.currTag)
	return
}



// GetSubjectHandler multiplexes to different implementations of the method.
func (merged *AgentRegistryCaller) GetSubjectHandler(opts *bind.CallOpts) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.6" {
		val, methodErr := merged.typ1.GetSubjectHandler(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("AgentRegistryCaller.GetSubjectHandler not implemented (tag=%s)", merged.currTag)
	return
}