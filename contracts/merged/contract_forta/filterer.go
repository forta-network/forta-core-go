// Code generated by go-merge-types. DO NOT EDIT.

package contract_forta

import (
	import_fmt "fmt"
	import_sync "sync"


	forta020 "github.com/forta-network/forta-core-go/contracts/generated/contract_forta_0_2_0"



	"github.com/ethereum/go-ethereum/accounts/abi/bind"

	"github.com/ethereum/go-ethereum/event"

	"github.com/ethereum/go-ethereum/core/types"

	"github.com/ethereum/go-ethereum/common"

	"math/big"

)

// FortaFilterer is a new type which can multiplex calls to different implementation types.
type FortaFilterer struct {

	typ0 *forta020.FortaFilterer

	currTag string
	mu import_sync.RWMutex
	unsafe bool // default: false
}

// NewFortaFilterer creates a new merged type.
func NewFortaFilterer(address common.Address, filterer bind.ContractFilterer) (*FortaFilterer, error) {
	var (
		mergedType FortaFilterer
		err error
	)
	mergedType.currTag = "0.2.0"


	mergedType.typ0, err = forta020.NewFortaFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize forta020.FortaFilterer: %v", err)
	}


	return &mergedType, nil
}

// IsKnownTagForFortaFilterer tells if given tag is a known tag.
func IsKnownTagForFortaFilterer(tag string) bool {

	if tag == "0.2.0" {
		return true
	}

	return false
}

// Use sets the used implementation to given tag.
func (merged *FortaFilterer) Use(tag string) (changed bool) {
	if !merged.unsafe {
		merged.mu.Lock()
		defer merged.mu.Unlock()
	}
	// use the default tag if the provided tag is unknown
	if !IsKnownTagForFortaFilterer(tag) {
		tag = "0.2.0"
	}
	changed = merged.currTag != tag
	merged.currTag = tag
	return
}

// Unsafe disables the mutex.
func (merged *FortaFilterer) Unsafe() {
	merged.unsafe = true
}

// Safe enables the mutex.
func (merged *FortaFilterer) Safe() {
	merged.unsafe = false
}




// FilterAdminChanged multiplexes to different implementations of the method.
func (merged *FortaFilterer) FilterAdminChanged(opts *bind.FilterOpts) (retVal *forta020.FortaAdminChangedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterAdminChanged(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.FilterAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}



// WatchAdminChanged multiplexes to different implementations of the method.
func (merged *FortaFilterer) WatchAdminChanged(opts *bind.WatchOpts, sink chan<- *forta020.FortaAdminChanged) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchAdminChanged(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.WatchAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}


// FortaAdminChanged is a merged return type.
type FortaAdminChanged struct {

	PreviousAdmin common.Address

	NewAdmin common.Address

	Raw types.Log

}

// ParseAdminChanged multiplexes to different implementations of the method.
func (merged *FortaFilterer) ParseAdminChanged(log types.Log) (retVal *FortaAdminChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaAdminChanged{}



	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseAdminChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaFilterer.ParseAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}



// FilterApproval multiplexes to different implementations of the method.
func (merged *FortaFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (retVal *forta020.FortaApprovalIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterApproval(opts, owner, spender)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.FilterApproval not implemented (tag=%s)", merged.currTag)
	return
}



// WatchApproval multiplexes to different implementations of the method.
func (merged *FortaFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *forta020.FortaApproval, owner []common.Address, spender []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchApproval(opts, sink, owner, spender)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.WatchApproval not implemented (tag=%s)", merged.currTag)
	return
}


// FortaApproval is a merged return type.
type FortaApproval struct {

	Owner common.Address

	Spender common.Address

	Value *big.Int

	Raw types.Log

}

// ParseApproval multiplexes to different implementations of the method.
func (merged *FortaFilterer) ParseApproval(log types.Log) (retVal *FortaApproval, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaApproval{}



	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseApproval(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Owner = val.Owner

		retVal.Spender = val.Spender

		retVal.Value = val.Value

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaFilterer.ParseApproval not implemented (tag=%s)", merged.currTag)
	return
}



// FilterBeaconUpgraded multiplexes to different implementations of the method.
func (merged *FortaFilterer) FilterBeaconUpgraded(opts *bind.FilterOpts, beacon []common.Address) (retVal *forta020.FortaBeaconUpgradedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterBeaconUpgraded(opts, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.FilterBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// WatchBeaconUpgraded multiplexes to different implementations of the method.
func (merged *FortaFilterer) WatchBeaconUpgraded(opts *bind.WatchOpts, sink chan<- *forta020.FortaBeaconUpgraded, beacon []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchBeaconUpgraded(opts, sink, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.WatchBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// FortaBeaconUpgraded is a merged return type.
type FortaBeaconUpgraded struct {

	Beacon common.Address

	Raw types.Log

}

// ParseBeaconUpgraded multiplexes to different implementations of the method.
func (merged *FortaFilterer) ParseBeaconUpgraded(log types.Log) (retVal *FortaBeaconUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaBeaconUpgraded{}



	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseBeaconUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaFilterer.ParseBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// FilterDelegateChanged multiplexes to different implementations of the method.
func (merged *FortaFilterer) FilterDelegateChanged(opts *bind.FilterOpts, delegator []common.Address, fromDelegate []common.Address, toDelegate []common.Address) (retVal *forta020.FortaDelegateChangedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterDelegateChanged(opts, delegator, fromDelegate, toDelegate)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.FilterDelegateChanged not implemented (tag=%s)", merged.currTag)
	return
}



// WatchDelegateChanged multiplexes to different implementations of the method.
func (merged *FortaFilterer) WatchDelegateChanged(opts *bind.WatchOpts, sink chan<- *forta020.FortaDelegateChanged, delegator []common.Address, fromDelegate []common.Address, toDelegate []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchDelegateChanged(opts, sink, delegator, fromDelegate, toDelegate)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.WatchDelegateChanged not implemented (tag=%s)", merged.currTag)
	return
}


// FortaDelegateChanged is a merged return type.
type FortaDelegateChanged struct {

	Delegator common.Address

	FromDelegate common.Address

	ToDelegate common.Address

	Raw types.Log

}

// ParseDelegateChanged multiplexes to different implementations of the method.
func (merged *FortaFilterer) ParseDelegateChanged(log types.Log) (retVal *FortaDelegateChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaDelegateChanged{}



	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseDelegateChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Delegator = val.Delegator

		retVal.FromDelegate = val.FromDelegate

		retVal.ToDelegate = val.ToDelegate

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaFilterer.ParseDelegateChanged not implemented (tag=%s)", merged.currTag)
	return
}



// FilterDelegateVotesChanged multiplexes to different implementations of the method.
func (merged *FortaFilterer) FilterDelegateVotesChanged(opts *bind.FilterOpts, delegate []common.Address) (retVal *forta020.FortaDelegateVotesChangedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterDelegateVotesChanged(opts, delegate)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.FilterDelegateVotesChanged not implemented (tag=%s)", merged.currTag)
	return
}



// WatchDelegateVotesChanged multiplexes to different implementations of the method.
func (merged *FortaFilterer) WatchDelegateVotesChanged(opts *bind.WatchOpts, sink chan<- *forta020.FortaDelegateVotesChanged, delegate []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchDelegateVotesChanged(opts, sink, delegate)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.WatchDelegateVotesChanged not implemented (tag=%s)", merged.currTag)
	return
}


// FortaDelegateVotesChanged is a merged return type.
type FortaDelegateVotesChanged struct {

	Delegate common.Address

	PreviousBalance *big.Int

	NewBalance *big.Int

	Raw types.Log

}

// ParseDelegateVotesChanged multiplexes to different implementations of the method.
func (merged *FortaFilterer) ParseDelegateVotesChanged(log types.Log) (retVal *FortaDelegateVotesChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaDelegateVotesChanged{}



	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseDelegateVotesChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Delegate = val.Delegate

		retVal.PreviousBalance = val.PreviousBalance

		retVal.NewBalance = val.NewBalance

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaFilterer.ParseDelegateVotesChanged not implemented (tag=%s)", merged.currTag)
	return
}



// FilterInitialized multiplexes to different implementations of the method.
func (merged *FortaFilterer) FilterInitialized(opts *bind.FilterOpts) (retVal *forta020.FortaInitializedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterInitialized(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.FilterInitialized not implemented (tag=%s)", merged.currTag)
	return
}



// WatchInitialized multiplexes to different implementations of the method.
func (merged *FortaFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *forta020.FortaInitialized) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchInitialized(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.WatchInitialized not implemented (tag=%s)", merged.currTag)
	return
}


// FortaInitialized is a merged return type.
type FortaInitialized struct {

	Version uint8

	Raw types.Log

}

// ParseInitialized multiplexes to different implementations of the method.
func (merged *FortaFilterer) ParseInitialized(log types.Log) (retVal *FortaInitialized, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaInitialized{}



	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseInitialized(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Version = val.Version

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaFilterer.ParseInitialized not implemented (tag=%s)", merged.currTag)
	return
}



// FilterRoleAdminChanged multiplexes to different implementations of the method.
func (merged *FortaFilterer) FilterRoleAdminChanged(opts *bind.FilterOpts, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (retVal *forta020.FortaRoleAdminChangedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterRoleAdminChanged(opts, role, previousAdminRole, newAdminRole)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.FilterRoleAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}



// WatchRoleAdminChanged multiplexes to different implementations of the method.
func (merged *FortaFilterer) WatchRoleAdminChanged(opts *bind.WatchOpts, sink chan<- *forta020.FortaRoleAdminChanged, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchRoleAdminChanged(opts, sink, role, previousAdminRole, newAdminRole)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.WatchRoleAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}


// FortaRoleAdminChanged is a merged return type.
type FortaRoleAdminChanged struct {

	Role [32]byte

	PreviousAdminRole [32]byte

	NewAdminRole [32]byte

	Raw types.Log

}

// ParseRoleAdminChanged multiplexes to different implementations of the method.
func (merged *FortaFilterer) ParseRoleAdminChanged(log types.Log) (retVal *FortaRoleAdminChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaRoleAdminChanged{}



	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseRoleAdminChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Role = val.Role

		retVal.PreviousAdminRole = val.PreviousAdminRole

		retVal.NewAdminRole = val.NewAdminRole

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaFilterer.ParseRoleAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}



// FilterRoleGranted multiplexes to different implementations of the method.
func (merged *FortaFilterer) FilterRoleGranted(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (retVal *forta020.FortaRoleGrantedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterRoleGranted(opts, role, account, sender)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.FilterRoleGranted not implemented (tag=%s)", merged.currTag)
	return
}



// WatchRoleGranted multiplexes to different implementations of the method.
func (merged *FortaFilterer) WatchRoleGranted(opts *bind.WatchOpts, sink chan<- *forta020.FortaRoleGranted, role [][32]byte, account []common.Address, sender []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchRoleGranted(opts, sink, role, account, sender)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.WatchRoleGranted not implemented (tag=%s)", merged.currTag)
	return
}


// FortaRoleGranted is a merged return type.
type FortaRoleGranted struct {

	Role [32]byte

	Account common.Address

	Sender common.Address

	Raw types.Log

}

// ParseRoleGranted multiplexes to different implementations of the method.
func (merged *FortaFilterer) ParseRoleGranted(log types.Log) (retVal *FortaRoleGranted, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaRoleGranted{}



	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseRoleGranted(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Role = val.Role

		retVal.Account = val.Account

		retVal.Sender = val.Sender

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaFilterer.ParseRoleGranted not implemented (tag=%s)", merged.currTag)
	return
}



// FilterRoleRevoked multiplexes to different implementations of the method.
func (merged *FortaFilterer) FilterRoleRevoked(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (retVal *forta020.FortaRoleRevokedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterRoleRevoked(opts, role, account, sender)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.FilterRoleRevoked not implemented (tag=%s)", merged.currTag)
	return
}



// WatchRoleRevoked multiplexes to different implementations of the method.
func (merged *FortaFilterer) WatchRoleRevoked(opts *bind.WatchOpts, sink chan<- *forta020.FortaRoleRevoked, role [][32]byte, account []common.Address, sender []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchRoleRevoked(opts, sink, role, account, sender)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.WatchRoleRevoked not implemented (tag=%s)", merged.currTag)
	return
}


// FortaRoleRevoked is a merged return type.
type FortaRoleRevoked struct {

	Role [32]byte

	Account common.Address

	Sender common.Address

	Raw types.Log

}

// ParseRoleRevoked multiplexes to different implementations of the method.
func (merged *FortaFilterer) ParseRoleRevoked(log types.Log) (retVal *FortaRoleRevoked, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaRoleRevoked{}



	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseRoleRevoked(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Role = val.Role

		retVal.Account = val.Account

		retVal.Sender = val.Sender

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaFilterer.ParseRoleRevoked not implemented (tag=%s)", merged.currTag)
	return
}



// FilterTransfer multiplexes to different implementations of the method.
func (merged *FortaFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (retVal *forta020.FortaTransferIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterTransfer(opts, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.FilterTransfer not implemented (tag=%s)", merged.currTag)
	return
}



// WatchTransfer multiplexes to different implementations of the method.
func (merged *FortaFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *forta020.FortaTransfer, from []common.Address, to []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchTransfer(opts, sink, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.WatchTransfer not implemented (tag=%s)", merged.currTag)
	return
}


// FortaTransfer is a merged return type.
type FortaTransfer struct {

	From common.Address

	To common.Address

	Value *big.Int

	Raw types.Log

}

// ParseTransfer multiplexes to different implementations of the method.
func (merged *FortaFilterer) ParseTransfer(log types.Log) (retVal *FortaTransfer, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaTransfer{}



	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseTransfer(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.From = val.From

		retVal.To = val.To

		retVal.Value = val.Value

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaFilterer.ParseTransfer not implemented (tag=%s)", merged.currTag)
	return
}



// FilterUpgraded multiplexes to different implementations of the method.
func (merged *FortaFilterer) FilterUpgraded(opts *bind.FilterOpts, implementation []common.Address) (retVal *forta020.FortaUpgradedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.FilterUpgraded(opts, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.FilterUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// WatchUpgraded multiplexes to different implementations of the method.
func (merged *FortaFilterer) WatchUpgraded(opts *bind.WatchOpts, sink chan<- *forta020.FortaUpgraded, implementation []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.WatchUpgraded(opts, sink, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaFilterer.WatchUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// FortaUpgraded is a merged return type.
type FortaUpgraded struct {

	Implementation common.Address

	Raw types.Log

}

// ParseUpgraded multiplexes to different implementations of the method.
func (merged *FortaFilterer) ParseUpgraded(log types.Log) (retVal *FortaUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaUpgraded{}



	if merged.currTag == "0.2.0" {
		val, methodErr := merged.typ0.ParseUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaFilterer.ParseUpgraded not implemented (tag=%s)", merged.currTag)
	return
}