// Code generated by go-merge-types. DO NOT EDIT.

package contract_scanner_pool_registry

import (
	import_fmt "fmt"
	import_sync "sync"


	scannerpoolregistry010 "github.com/forta-network/forta-core-go/contracts/generated/contract_scanner_pool_registry_0_1_0"



	"github.com/ethereum/go-ethereum/accounts/abi/bind"

	"github.com/ethereum/go-ethereum/common"

	"math/big"

)

// ScannerPoolRegistryCaller is a new type which can multiplex calls to different implementation types.
type ScannerPoolRegistryCaller struct {

	typ0 *scannerpoolregistry010.ScannerPoolRegistryCaller

	currTag string
	mu import_sync.RWMutex
	unsafe bool // default: false
}

// NewScannerPoolRegistryCaller creates a new merged type.
func NewScannerPoolRegistryCaller(address common.Address, caller bind.ContractCaller) (*ScannerPoolRegistryCaller, error) {
	var (
		mergedType ScannerPoolRegistryCaller
		err error
	)
	mergedType.currTag = "0.1.0"


	mergedType.typ0, err = scannerpoolregistry010.NewScannerPoolRegistryCaller(address, caller)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize scannerpoolregistry010.ScannerPoolRegistryCaller: %v", err)
	}


	return &mergedType, nil
}

// IsKnownTagForScannerPoolRegistryCaller tells if given tag is a known tag.
func IsKnownTagForScannerPoolRegistryCaller(tag string) bool {

	if tag == "0.1.0" {
		return true
	}

	return false
}

// Use sets the used implementation to given tag.
func (merged *ScannerPoolRegistryCaller) Use(tag string) (changed bool) {
	if !merged.unsafe {
		merged.mu.Lock()
		defer merged.mu.Unlock()
	}
	// use the default tag if the provided tag is unknown
	if !IsKnownTagForScannerPoolRegistryCaller(tag) {
		tag = "0.1.0"
	}
	changed = merged.currTag != tag
	merged.currTag = tag
	return
}

// Unsafe disables the mutex.
func (merged *ScannerPoolRegistryCaller) Unsafe() {
	merged.unsafe = true
}

// Safe enables the mutex.
func (merged *ScannerPoolRegistryCaller) Safe() {
	merged.unsafe = false
}




// BalanceOf multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) BalanceOf(opts *bind.CallOpts, owner common.Address) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.BalanceOf(opts, owner)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.BalanceOf not implemented (tag=%s)", merged.currTag)
	return
}



// GetApproved multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.GetApproved(opts, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.GetApproved not implemented (tag=%s)", merged.currTag)
	return
}


// GetManagedStakeThresholdOutput is a merged return type.
type GetManagedStakeThresholdOutput struct {

	Min *big.Int

	Max *big.Int

	Activated bool

}

// GetManagedStakeThreshold multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) GetManagedStakeThreshold(opts *bind.CallOpts, managedId *big.Int) (retVal *GetManagedStakeThresholdOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &GetManagedStakeThresholdOutput{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.GetManagedStakeThreshold(opts, managedId)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Min = val.Min

		retVal.Max = val.Max

		retVal.Activated = val.Activated


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.GetManagedStakeThreshold not implemented (tag=%s)", merged.currTag)
	return
}



// GetManagerAt multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) GetManagerAt(opts *bind.CallOpts, scannerPoolId *big.Int, index *big.Int) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.GetManagerAt(opts, scannerPoolId, index)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.GetManagerAt not implemented (tag=%s)", merged.currTag)
	return
}



// GetManagerCount multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) GetManagerCount(opts *bind.CallOpts, scannerPoolId *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.GetManagerCount(opts, scannerPoolId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.GetManagerCount not implemented (tag=%s)", merged.currTag)
	return
}


// GetScannerOutput is a merged return type.
type GetScannerOutput struct {

	Registered bool

	Disabled bool

	ScannerPoolId *big.Int

	ChainId *big.Int

	Metadata string

}

// GetScanner multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) GetScanner(opts *bind.CallOpts, scanner common.Address) (retVal *GetScannerOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &GetScannerOutput{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.GetScanner(opts, scanner)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Registered = val.Registered

		retVal.Disabled = val.Disabled

		retVal.ScannerPoolId = val.ScannerPoolId

		retVal.ChainId = val.ChainId

		retVal.Metadata = val.Metadata


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.GetScanner not implemented (tag=%s)", merged.currTag)
	return
}


// GetScannerStateOutput is a merged return type.
type GetScannerStateOutput struct {

	Registered bool

	Owner common.Address

	ChainId *big.Int

	Metadata string

	Operational bool

	Disabled bool

}

// GetScannerState multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) GetScannerState(opts *bind.CallOpts, scanner common.Address) (retVal *GetScannerStateOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &GetScannerStateOutput{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.GetScannerState(opts, scanner)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Registered = val.Registered

		retVal.Owner = val.Owner

		retVal.ChainId = val.ChainId

		retVal.Metadata = val.Metadata

		retVal.Operational = val.Operational

		retVal.Disabled = val.Disabled


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.GetScannerState not implemented (tag=%s)", merged.currTag)
	return
}



// GetSubjectHandler multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) GetSubjectHandler(opts *bind.CallOpts) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.GetSubjectHandler(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.GetSubjectHandler not implemented (tag=%s)", merged.currTag)
	return
}



// GetTotalManagedSubjects multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) GetTotalManagedSubjects(opts *bind.CallOpts, subject *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.GetTotalManagedSubjects(opts, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.GetTotalManagedSubjects not implemented (tag=%s)", merged.currTag)
	return
}



// IsApprovedForAll multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.IsApprovedForAll(opts, owner, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.IsApprovedForAll not implemented (tag=%s)", merged.currTag)
	return
}



// IsManager multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) IsManager(opts *bind.CallOpts, scannerPoolId *big.Int, manager common.Address) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.IsManager(opts, scannerPoolId, manager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.IsManager not implemented (tag=%s)", merged.currTag)
	return
}



// IsRegistered multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) IsRegistered(opts *bind.CallOpts, scannerPoolId *big.Int) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.IsRegistered(opts, scannerPoolId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.IsRegistered not implemented (tag=%s)", merged.currTag)
	return
}



// IsScannerDisabled multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) IsScannerDisabled(opts *bind.CallOpts, scanner common.Address) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.IsScannerDisabled(opts, scanner)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.IsScannerDisabled not implemented (tag=%s)", merged.currTag)
	return
}



// IsScannerOperational multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) IsScannerOperational(opts *bind.CallOpts, scanner common.Address) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.IsScannerOperational(opts, scanner)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.IsScannerOperational not implemented (tag=%s)", merged.currTag)
	return
}



// IsScannerRegistered multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) IsScannerRegistered(opts *bind.CallOpts, scanner common.Address) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.IsScannerRegistered(opts, scanner)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.IsScannerRegistered not implemented (tag=%s)", merged.currTag)
	return
}



// IsScannerRegisteredTo multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) IsScannerRegisteredTo(opts *bind.CallOpts, scanner common.Address, scannerPoolId *big.Int) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.IsScannerRegisteredTo(opts, scanner, scannerPoolId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.IsScannerRegisteredTo not implemented (tag=%s)", merged.currTag)
	return
}



// IsTrustedForwarder multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) IsTrustedForwarder(opts *bind.CallOpts, forwarder common.Address) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.IsTrustedForwarder(opts, forwarder)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.IsTrustedForwarder not implemented (tag=%s)", merged.currTag)
	return
}



// MonitoredChainId multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) MonitoredChainId(opts *bind.CallOpts, scannerPoolId *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.MonitoredChainId(opts, scannerPoolId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.MonitoredChainId not implemented (tag=%s)", merged.currTag)
	return
}



// Name multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) Name(opts *bind.CallOpts) (retVal string, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.Name(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.Name not implemented (tag=%s)", merged.currTag)
	return
}



// OwnerOf multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) OwnerOf(opts *bind.CallOpts, subject *big.Int) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.OwnerOf(opts, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.OwnerOf not implemented (tag=%s)", merged.currTag)
	return
}



// ProxiableUUID multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) ProxiableUUID(opts *bind.CallOpts) (retVal [32]byte, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ProxiableUUID(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.ProxiableUUID not implemented (tag=%s)", merged.currTag)
	return
}



// RegisteredScannerAddressAtIndex multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) RegisteredScannerAddressAtIndex(opts *bind.CallOpts, scannerPoolId *big.Int, index *big.Int) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.RegisteredScannerAddressAtIndex(opts, scannerPoolId, index)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.RegisteredScannerAddressAtIndex not implemented (tag=%s)", merged.currTag)
	return
}


// RegisteredScannerAtIndexOutput is a merged return type.
type RegisteredScannerAtIndexOutput struct {

	Registered bool

	Disabled bool

	ScannerPoolId *big.Int

	ChainId *big.Int

	Metadata string

}

// RegisteredScannerAtIndex multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) RegisteredScannerAtIndex(opts *bind.CallOpts, scannerPoolId *big.Int, index *big.Int) (retVal *RegisteredScannerAtIndexOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &RegisteredScannerAtIndexOutput{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.RegisteredScannerAtIndex(opts, scannerPoolId, index)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Registered = val.Registered

		retVal.Disabled = val.Disabled

		retVal.ScannerPoolId = val.ScannerPoolId

		retVal.ChainId = val.ChainId

		retVal.Metadata = val.Metadata


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.RegisteredScannerAtIndex not implemented (tag=%s)", merged.currTag)
	return
}



// RegistrationDelay multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) RegistrationDelay(opts *bind.CallOpts) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.RegistrationDelay(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.RegistrationDelay not implemented (tag=%s)", merged.currTag)
	return
}



// ScannerAddressToId multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) ScannerAddressToId(opts *bind.CallOpts, scanner common.Address) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ScannerAddressToId(opts, scanner)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.ScannerAddressToId not implemented (tag=%s)", merged.currTag)
	return
}



// ScannerIdToAddress multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) ScannerIdToAddress(opts *bind.CallOpts, scannerId *big.Int) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ScannerIdToAddress(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.ScannerIdToAddress not implemented (tag=%s)", merged.currTag)
	return
}



// SupportsInterface multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.SupportsInterface(opts, interfaceId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.SupportsInterface not implemented (tag=%s)", merged.currTag)
	return
}



// Symbol multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) Symbol(opts *bind.CallOpts) (retVal string, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.Symbol(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.Symbol not implemented (tag=%s)", merged.currTag)
	return
}



// TokenByIndex multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) TokenByIndex(opts *bind.CallOpts, index *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.TokenByIndex(opts, index)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.TokenByIndex not implemented (tag=%s)", merged.currTag)
	return
}



// TokenOfOwnerByIndex multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) TokenOfOwnerByIndex(opts *bind.CallOpts, owner common.Address, index *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.TokenOfOwnerByIndex(opts, owner, index)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.TokenOfOwnerByIndex not implemented (tag=%s)", merged.currTag)
	return
}



// TokenURI multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) TokenURI(opts *bind.CallOpts, tokenId *big.Int) (retVal string, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.TokenURI(opts, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.TokenURI not implemented (tag=%s)", merged.currTag)
	return
}



// TotalScannersRegistered multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) TotalScannersRegistered(opts *bind.CallOpts, scannerPoolId *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.TotalScannersRegistered(opts, scannerPoolId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.TotalScannersRegistered not implemented (tag=%s)", merged.currTag)
	return
}



// TotalSupply multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) TotalSupply(opts *bind.CallOpts) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.TotalSupply(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.TotalSupply not implemented (tag=%s)", merged.currTag)
	return
}



// Version multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) Version(opts *bind.CallOpts) (retVal string, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.Version(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.Version not implemented (tag=%s)", merged.currTag)
	return
}



// WillNewScannerShutdownPool multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryCaller) WillNewScannerShutdownPool(opts *bind.CallOpts, scannerPoolId *big.Int) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WillNewScannerShutdownPool(opts, scannerPoolId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryCaller.WillNewScannerShutdownPool not implemented (tag=%s)", merged.currTag)
	return
}