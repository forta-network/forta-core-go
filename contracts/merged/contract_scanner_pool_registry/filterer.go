// Code generated by go-merge-types. DO NOT EDIT.

package contract_scanner_pool_registry

import (
	import_fmt "fmt"
	import_sync "sync"


	scannerpoolregistry010 "github.com/forta-network/forta-core-go/contracts/generated/contract_scanner_pool_registry_0_1_0"



	"github.com/ethereum/go-ethereum/accounts/abi/bind"

	"github.com/ethereum/go-ethereum/event"

	"github.com/ethereum/go-ethereum/core/types"

	"github.com/ethereum/go-ethereum/common"

	"math/big"

)

// ScannerPoolRegistryFilterer is a new type which can multiplex calls to different implementation types.
type ScannerPoolRegistryFilterer struct {

	typ0 *scannerpoolregistry010.ScannerPoolRegistryFilterer

	currTag string
	mu import_sync.RWMutex
	unsafe bool // default: false
}

// NewScannerPoolRegistryFilterer creates a new merged type.
func NewScannerPoolRegistryFilterer(address common.Address, filterer bind.ContractFilterer) (*ScannerPoolRegistryFilterer, error) {
	var (
		mergedType ScannerPoolRegistryFilterer
		err error
	)
	mergedType.currTag = "0.1.0"


	mergedType.typ0, err = scannerpoolregistry010.NewScannerPoolRegistryFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize scannerpoolregistry010.ScannerPoolRegistryFilterer: %v", err)
	}


	return &mergedType, nil
}

// IsKnownTagForScannerPoolRegistryFilterer tells if given tag is a known tag.
func IsKnownTagForScannerPoolRegistryFilterer(tag string) bool {

	if tag == "0.1.0" {
		return true
	}

	return false
}

// Use sets the used implementation to given tag.
func (merged *ScannerPoolRegistryFilterer) Use(tag string) (changed bool) {
	if !merged.unsafe {
		merged.mu.Lock()
		defer merged.mu.Unlock()
	}
	// use the default tag if the provided tag is unknown
	if !IsKnownTagForScannerPoolRegistryFilterer(tag) {
		tag = "0.1.0"
	}
	changed = merged.currTag != tag
	merged.currTag = tag
	return
}

// Unsafe disables the mutex.
func (merged *ScannerPoolRegistryFilterer) Unsafe() {
	merged.unsafe = true
}

// Safe enables the mutex.
func (merged *ScannerPoolRegistryFilterer) Safe() {
	merged.unsafe = false
}




// FilterAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) FilterAccessManagerUpdated(opts *bind.FilterOpts, newAddressManager []common.Address) (retVal *scannerpoolregistry010.ScannerPoolRegistryAccessManagerUpdatedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterAccessManagerUpdated(opts, newAddressManager)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.FilterAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) WatchAccessManagerUpdated(opts *bind.WatchOpts, sink chan<- *scannerpoolregistry010.ScannerPoolRegistryAccessManagerUpdated, newAddressManager []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchAccessManagerUpdated(opts, sink, newAddressManager)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.WatchAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerPoolRegistryAccessManagerUpdated is a merged return type.
type ScannerPoolRegistryAccessManagerUpdated struct {

	NewAddressManager common.Address

	Raw types.Log

}

// ParseAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) ParseAccessManagerUpdated(log types.Log) (retVal *ScannerPoolRegistryAccessManagerUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerPoolRegistryAccessManagerUpdated{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseAccessManagerUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.NewAddressManager = val.NewAddressManager

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.ParseAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// FilterAdminChanged multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) FilterAdminChanged(opts *bind.FilterOpts) (retVal *scannerpoolregistry010.ScannerPoolRegistryAdminChangedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterAdminChanged(opts)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.FilterAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}



// WatchAdminChanged multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) WatchAdminChanged(opts *bind.WatchOpts, sink chan<- *scannerpoolregistry010.ScannerPoolRegistryAdminChanged) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchAdminChanged(opts, sink)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.WatchAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerPoolRegistryAdminChanged is a merged return type.
type ScannerPoolRegistryAdminChanged struct {

	PreviousAdmin common.Address

	NewAdmin common.Address

	Raw types.Log

}

// ParseAdminChanged multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) ParseAdminChanged(log types.Log) (retVal *ScannerPoolRegistryAdminChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerPoolRegistryAdminChanged{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseAdminChanged(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.ParseAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}



// FilterApproval multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (retVal *scannerpoolregistry010.ScannerPoolRegistryApprovalIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterApproval(opts, owner, approved, tokenId)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.FilterApproval not implemented (tag=%s)", merged.currTag)
	return
}



// WatchApproval multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *scannerpoolregistry010.ScannerPoolRegistryApproval, owner []common.Address, approved []common.Address, tokenId []*big.Int) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchApproval(opts, sink, owner, approved, tokenId)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.WatchApproval not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerPoolRegistryApproval is a merged return type.
type ScannerPoolRegistryApproval struct {

	Owner common.Address

	Approved common.Address

	TokenId *big.Int

	Raw types.Log

}

// ParseApproval multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) ParseApproval(log types.Log) (retVal *ScannerPoolRegistryApproval, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerPoolRegistryApproval{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseApproval(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Owner = val.Owner

		retVal.Approved = val.Approved

		retVal.TokenId = val.TokenId

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.ParseApproval not implemented (tag=%s)", merged.currTag)
	return
}



// FilterApprovalForAll multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (retVal *scannerpoolregistry010.ScannerPoolRegistryApprovalForAllIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterApprovalForAll(opts, owner, operator)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.FilterApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}



// WatchApprovalForAll multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *scannerpoolregistry010.ScannerPoolRegistryApprovalForAll, owner []common.Address, operator []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchApprovalForAll(opts, sink, owner, operator)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.WatchApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerPoolRegistryApprovalForAll is a merged return type.
type ScannerPoolRegistryApprovalForAll struct {

	Owner common.Address

	Operator common.Address

	Approved bool

	Raw types.Log

}

// ParseApprovalForAll multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) ParseApprovalForAll(log types.Log) (retVal *ScannerPoolRegistryApprovalForAll, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerPoolRegistryApprovalForAll{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseApprovalForAll(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Owner = val.Owner

		retVal.Operator = val.Operator

		retVal.Approved = val.Approved

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.ParseApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}



// FilterBeaconUpgraded multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) FilterBeaconUpgraded(opts *bind.FilterOpts, beacon []common.Address) (retVal *scannerpoolregistry010.ScannerPoolRegistryBeaconUpgradedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterBeaconUpgraded(opts, beacon)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.FilterBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// WatchBeaconUpgraded multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) WatchBeaconUpgraded(opts *bind.WatchOpts, sink chan<- *scannerpoolregistry010.ScannerPoolRegistryBeaconUpgraded, beacon []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchBeaconUpgraded(opts, sink, beacon)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.WatchBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerPoolRegistryBeaconUpgraded is a merged return type.
type ScannerPoolRegistryBeaconUpgraded struct {

	Beacon common.Address

	Raw types.Log

}

// ParseBeaconUpgraded multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) ParseBeaconUpgraded(log types.Log) (retVal *ScannerPoolRegistryBeaconUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerPoolRegistryBeaconUpgraded{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseBeaconUpgraded(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.ParseBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// FilterEnabledScannersChanged multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) FilterEnabledScannersChanged(opts *bind.FilterOpts, scannerPoolId []*big.Int) (retVal *scannerpoolregistry010.ScannerPoolRegistryEnabledScannersChangedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterEnabledScannersChanged(opts, scannerPoolId)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.FilterEnabledScannersChanged not implemented (tag=%s)", merged.currTag)
	return
}



// WatchEnabledScannersChanged multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) WatchEnabledScannersChanged(opts *bind.WatchOpts, sink chan<- *scannerpoolregistry010.ScannerPoolRegistryEnabledScannersChanged, scannerPoolId []*big.Int) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchEnabledScannersChanged(opts, sink, scannerPoolId)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.WatchEnabledScannersChanged not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerPoolRegistryEnabledScannersChanged is a merged return type.
type ScannerPoolRegistryEnabledScannersChanged struct {

	ScannerPoolId *big.Int

	EnabledScanners *big.Int

	Raw types.Log

}

// ParseEnabledScannersChanged multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) ParseEnabledScannersChanged(log types.Log) (retVal *ScannerPoolRegistryEnabledScannersChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerPoolRegistryEnabledScannersChanged{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseEnabledScannersChanged(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.ScannerPoolId = val.ScannerPoolId

		retVal.EnabledScanners = val.EnabledScanners

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.ParseEnabledScannersChanged not implemented (tag=%s)", merged.currTag)
	return
}



// FilterInitialized multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) FilterInitialized(opts *bind.FilterOpts) (retVal *scannerpoolregistry010.ScannerPoolRegistryInitializedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterInitialized(opts)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.FilterInitialized not implemented (tag=%s)", merged.currTag)
	return
}



// WatchInitialized multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *scannerpoolregistry010.ScannerPoolRegistryInitialized) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchInitialized(opts, sink)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.WatchInitialized not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerPoolRegistryInitialized is a merged return type.
type ScannerPoolRegistryInitialized struct {

	Version uint8

	Raw types.Log

}

// ParseInitialized multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) ParseInitialized(log types.Log) (retVal *ScannerPoolRegistryInitialized, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerPoolRegistryInitialized{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseInitialized(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Version = val.Version

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.ParseInitialized not implemented (tag=%s)", merged.currTag)
	return
}



// FilterManagedStakeThresholdChanged multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) FilterManagedStakeThresholdChanged(opts *bind.FilterOpts, chainId []*big.Int) (retVal *scannerpoolregistry010.ScannerPoolRegistryManagedStakeThresholdChangedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterManagedStakeThresholdChanged(opts, chainId)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.FilterManagedStakeThresholdChanged not implemented (tag=%s)", merged.currTag)
	return
}



// WatchManagedStakeThresholdChanged multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) WatchManagedStakeThresholdChanged(opts *bind.WatchOpts, sink chan<- *scannerpoolregistry010.ScannerPoolRegistryManagedStakeThresholdChanged, chainId []*big.Int) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchManagedStakeThresholdChanged(opts, sink, chainId)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.WatchManagedStakeThresholdChanged not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerPoolRegistryManagedStakeThresholdChanged is a merged return type.
type ScannerPoolRegistryManagedStakeThresholdChanged struct {

	ChainId *big.Int

	Min *big.Int

	Max *big.Int

	Activated bool

	Raw types.Log

}

// ParseManagedStakeThresholdChanged multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) ParseManagedStakeThresholdChanged(log types.Log) (retVal *ScannerPoolRegistryManagedStakeThresholdChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerPoolRegistryManagedStakeThresholdChanged{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseManagedStakeThresholdChanged(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.ChainId = val.ChainId

		retVal.Min = val.Min

		retVal.Max = val.Max

		retVal.Activated = val.Activated

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.ParseManagedStakeThresholdChanged not implemented (tag=%s)", merged.currTag)
	return
}



// FilterManagerEnabled multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) FilterManagerEnabled(opts *bind.FilterOpts, scannerPoolId []*big.Int, manager []common.Address) (retVal *scannerpoolregistry010.ScannerPoolRegistryManagerEnabledIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterManagerEnabled(opts, scannerPoolId, manager)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.FilterManagerEnabled not implemented (tag=%s)", merged.currTag)
	return
}



// WatchManagerEnabled multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) WatchManagerEnabled(opts *bind.WatchOpts, sink chan<- *scannerpoolregistry010.ScannerPoolRegistryManagerEnabled, scannerPoolId []*big.Int, manager []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchManagerEnabled(opts, sink, scannerPoolId, manager)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.WatchManagerEnabled not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerPoolRegistryManagerEnabled is a merged return type.
type ScannerPoolRegistryManagerEnabled struct {

	ScannerPoolId *big.Int

	Manager common.Address

	Enabled bool

	Raw types.Log

}

// ParseManagerEnabled multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) ParseManagerEnabled(log types.Log) (retVal *ScannerPoolRegistryManagerEnabled, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerPoolRegistryManagerEnabled{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseManagerEnabled(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.ScannerPoolId = val.ScannerPoolId

		retVal.Manager = val.Manager

		retVal.Enabled = val.Enabled

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.ParseManagerEnabled not implemented (tag=%s)", merged.currTag)
	return
}



// FilterRegistrationDelaySet multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) FilterRegistrationDelaySet(opts *bind.FilterOpts) (retVal *scannerpoolregistry010.ScannerPoolRegistryRegistrationDelaySetIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterRegistrationDelaySet(opts)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.FilterRegistrationDelaySet not implemented (tag=%s)", merged.currTag)
	return
}



// WatchRegistrationDelaySet multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) WatchRegistrationDelaySet(opts *bind.WatchOpts, sink chan<- *scannerpoolregistry010.ScannerPoolRegistryRegistrationDelaySet) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchRegistrationDelaySet(opts, sink)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.WatchRegistrationDelaySet not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerPoolRegistryRegistrationDelaySet is a merged return type.
type ScannerPoolRegistryRegistrationDelaySet struct {

	Delay *big.Int

	Raw types.Log

}

// ParseRegistrationDelaySet multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) ParseRegistrationDelaySet(log types.Log) (retVal *ScannerPoolRegistryRegistrationDelaySet, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerPoolRegistryRegistrationDelaySet{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseRegistrationDelaySet(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Delay = val.Delay

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.ParseRegistrationDelaySet not implemented (tag=%s)", merged.currTag)
	return
}



// FilterRouterUpdated multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) FilterRouterUpdated(opts *bind.FilterOpts, router []common.Address) (retVal *scannerpoolregistry010.ScannerPoolRegistryRouterUpdatedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterRouterUpdated(opts, router)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.FilterRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchRouterUpdated multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) WatchRouterUpdated(opts *bind.WatchOpts, sink chan<- *scannerpoolregistry010.ScannerPoolRegistryRouterUpdated, router []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchRouterUpdated(opts, sink, router)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.WatchRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerPoolRegistryRouterUpdated is a merged return type.
type ScannerPoolRegistryRouterUpdated struct {

	Router common.Address

	Raw types.Log

}

// ParseRouterUpdated multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) ParseRouterUpdated(log types.Log) (retVal *ScannerPoolRegistryRouterUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerPoolRegistryRouterUpdated{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseRouterUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Router = val.Router

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.ParseRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// FilterScannerEnabled multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) FilterScannerEnabled(opts *bind.FilterOpts, scannerId []*big.Int, enabled []bool) (retVal *scannerpoolregistry010.ScannerPoolRegistryScannerEnabledIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterScannerEnabled(opts, scannerId, enabled)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.FilterScannerEnabled not implemented (tag=%s)", merged.currTag)
	return
}



// WatchScannerEnabled multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) WatchScannerEnabled(opts *bind.WatchOpts, sink chan<- *scannerpoolregistry010.ScannerPoolRegistryScannerEnabled, scannerId []*big.Int, enabled []bool) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchScannerEnabled(opts, sink, scannerId, enabled)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.WatchScannerEnabled not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerPoolRegistryScannerEnabled is a merged return type.
type ScannerPoolRegistryScannerEnabled struct {

	ScannerId *big.Int

	Enabled bool

	Sender common.Address

	DisableFlag bool

	Raw types.Log

}

// ParseScannerEnabled multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) ParseScannerEnabled(log types.Log) (retVal *ScannerPoolRegistryScannerEnabled, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerPoolRegistryScannerEnabled{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseScannerEnabled(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.ScannerId = val.ScannerId

		retVal.Enabled = val.Enabled

		retVal.Sender = val.Sender

		retVal.DisableFlag = val.DisableFlag

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.ParseScannerEnabled not implemented (tag=%s)", merged.currTag)
	return
}



// FilterScannerPoolRegistered multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) FilterScannerPoolRegistered(opts *bind.FilterOpts, scannerPoolId []*big.Int, chainId []*big.Int) (retVal *scannerpoolregistry010.ScannerPoolRegistryScannerPoolRegisteredIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterScannerPoolRegistered(opts, scannerPoolId, chainId)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.FilterScannerPoolRegistered not implemented (tag=%s)", merged.currTag)
	return
}



// WatchScannerPoolRegistered multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) WatchScannerPoolRegistered(opts *bind.WatchOpts, sink chan<- *scannerpoolregistry010.ScannerPoolRegistryScannerPoolRegistered, scannerPoolId []*big.Int, chainId []*big.Int) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchScannerPoolRegistered(opts, sink, scannerPoolId, chainId)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.WatchScannerPoolRegistered not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerPoolRegistryScannerPoolRegistered is a merged return type.
type ScannerPoolRegistryScannerPoolRegistered struct {

	ScannerPoolId *big.Int

	ChainId *big.Int

	Raw types.Log

}

// ParseScannerPoolRegistered multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) ParseScannerPoolRegistered(log types.Log) (retVal *ScannerPoolRegistryScannerPoolRegistered, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerPoolRegistryScannerPoolRegistered{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseScannerPoolRegistered(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.ScannerPoolId = val.ScannerPoolId

		retVal.ChainId = val.ChainId

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.ParseScannerPoolRegistered not implemented (tag=%s)", merged.currTag)
	return
}



// FilterScannerUpdated multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) FilterScannerUpdated(opts *bind.FilterOpts, scannerId []*big.Int, chainId []*big.Int) (retVal *scannerpoolregistry010.ScannerPoolRegistryScannerUpdatedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterScannerUpdated(opts, scannerId, chainId)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.FilterScannerUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchScannerUpdated multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) WatchScannerUpdated(opts *bind.WatchOpts, sink chan<- *scannerpoolregistry010.ScannerPoolRegistryScannerUpdated, scannerId []*big.Int, chainId []*big.Int) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchScannerUpdated(opts, sink, scannerId, chainId)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.WatchScannerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerPoolRegistryScannerUpdated is a merged return type.
type ScannerPoolRegistryScannerUpdated struct {

	ScannerId *big.Int

	ChainId *big.Int

	Metadata string

	ScannerPool *big.Int

	Raw types.Log

}

// ParseScannerUpdated multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) ParseScannerUpdated(log types.Log) (retVal *ScannerPoolRegistryScannerUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerPoolRegistryScannerUpdated{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseScannerUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.ScannerId = val.ScannerId

		retVal.ChainId = val.ChainId

		retVal.Metadata = val.Metadata

		retVal.ScannerPool = val.ScannerPool

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.ParseScannerUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// FilterSubjectHandlerUpdated multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) FilterSubjectHandlerUpdated(opts *bind.FilterOpts, newHandler []common.Address) (retVal *scannerpoolregistry010.ScannerPoolRegistrySubjectHandlerUpdatedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterSubjectHandlerUpdated(opts, newHandler)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.FilterSubjectHandlerUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchSubjectHandlerUpdated multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) WatchSubjectHandlerUpdated(opts *bind.WatchOpts, sink chan<- *scannerpoolregistry010.ScannerPoolRegistrySubjectHandlerUpdated, newHandler []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchSubjectHandlerUpdated(opts, sink, newHandler)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.WatchSubjectHandlerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerPoolRegistrySubjectHandlerUpdated is a merged return type.
type ScannerPoolRegistrySubjectHandlerUpdated struct {

	NewHandler common.Address

	Raw types.Log

}

// ParseSubjectHandlerUpdated multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) ParseSubjectHandlerUpdated(log types.Log) (retVal *ScannerPoolRegistrySubjectHandlerUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerPoolRegistrySubjectHandlerUpdated{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseSubjectHandlerUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.NewHandler = val.NewHandler

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.ParseSubjectHandlerUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// FilterTransfer multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (retVal *scannerpoolregistry010.ScannerPoolRegistryTransferIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterTransfer(opts, from, to, tokenId)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.FilterTransfer not implemented (tag=%s)", merged.currTag)
	return
}



// WatchTransfer multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *scannerpoolregistry010.ScannerPoolRegistryTransfer, from []common.Address, to []common.Address, tokenId []*big.Int) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchTransfer(opts, sink, from, to, tokenId)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.WatchTransfer not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerPoolRegistryTransfer is a merged return type.
type ScannerPoolRegistryTransfer struct {

	From common.Address

	To common.Address

	TokenId *big.Int

	Raw types.Log

}

// ParseTransfer multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) ParseTransfer(log types.Log) (retVal *ScannerPoolRegistryTransfer, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerPoolRegistryTransfer{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseTransfer(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.From = val.From

		retVal.To = val.To

		retVal.TokenId = val.TokenId

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.ParseTransfer not implemented (tag=%s)", merged.currTag)
	return
}



// FilterUpgraded multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) FilterUpgraded(opts *bind.FilterOpts, implementation []common.Address) (retVal *scannerpoolregistry010.ScannerPoolRegistryUpgradedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterUpgraded(opts, implementation)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.FilterUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// WatchUpgraded multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) WatchUpgraded(opts *bind.WatchOpts, sink chan<- *scannerpoolregistry010.ScannerPoolRegistryUpgraded, implementation []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchUpgraded(opts, sink, implementation)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.WatchUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerPoolRegistryUpgraded is a merged return type.
type ScannerPoolRegistryUpgraded struct {

	Implementation common.Address

	Raw types.Log

}

// ParseUpgraded multiplexes to different implementations of the method.
func (merged *ScannerPoolRegistryFilterer) ParseUpgraded(log types.Log) (retVal *ScannerPoolRegistryUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerPoolRegistryUpgraded{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseUpgraded(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerPoolRegistryFilterer.ParseUpgraded not implemented (tag=%s)", merged.currTag)
	return
}