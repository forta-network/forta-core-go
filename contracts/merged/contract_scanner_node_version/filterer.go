// Code generated by go-merge-types. DO NOT EDIT.

package contract_scanner_node_version

import (
	import_fmt "fmt"
	import_sync "sync"


	scannernodeversion010 "github.com/forta-network/forta-core-go/contracts/generated/contract_scanner_node_version_0_1_0"

	scannernodeversion011 "github.com/forta-network/forta-core-go/contracts/generated/contract_scanner_node_version_0_1_1"



	"github.com/ethereum/go-ethereum/accounts/abi/bind"

	"github.com/ethereum/go-ethereum/event"

	"github.com/ethereum/go-ethereum/core/types"

	"github.com/ethereum/go-ethereum/common"

)

// ScannerNodeVersionFilterer is a new type which can multiplex calls to different implementation types.
type ScannerNodeVersionFilterer struct {

	typ0 *scannernodeversion010.ScannerNodeVersionFilterer

	typ1 *scannernodeversion011.ScannerNodeVersionFilterer

	currTag string
	mu import_sync.RWMutex
	unsafe bool // default: false
}

// NewScannerNodeVersionFilterer creates a new merged type.
func NewScannerNodeVersionFilterer(address common.Address, filterer bind.ContractFilterer) (*ScannerNodeVersionFilterer, error) {
	var (
		mergedType ScannerNodeVersionFilterer
		err error
	)
	mergedType.currTag = "0.1.0"


	mergedType.typ0, err = scannernodeversion010.NewScannerNodeVersionFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize scannernodeversion010.ScannerNodeVersionFilterer: %v", err)
	}

	mergedType.typ1, err = scannernodeversion011.NewScannerNodeVersionFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize scannernodeversion011.ScannerNodeVersionFilterer: %v", err)
	}


	return &mergedType, nil
}

// IsKnownTagForScannerNodeVersionFilterer tells if given tag is a known tag.
func IsKnownTagForScannerNodeVersionFilterer(tag string) bool {

	if tag == "0.1.0" {
		return true
	}

	if tag == "0.1.1" {
		return true
	}

	return false
}

// Use sets the used implementation to given tag.
func (merged *ScannerNodeVersionFilterer) Use(tag string) (changed bool) {
	if !merged.unsafe {
		merged.mu.Lock()
		defer merged.mu.Unlock()
	}
	// use the default tag if the provided tag is unknown
	if !IsKnownTagForScannerNodeVersionFilterer(tag) {
		tag = "0.1.0"
	}
	changed = merged.currTag != tag
	merged.currTag = tag
	return
}

// Unsafe disables the mutex.
func (merged *ScannerNodeVersionFilterer) Unsafe() {
	merged.unsafe = true
}

// Safe enables the mutex.
func (merged *ScannerNodeVersionFilterer) Safe() {
	merged.unsafe = false
}



// FilterAccessManagerUpdatedOutput is a merged return type.
type FilterAccessManagerUpdatedOutput struct {

	Scannernodeversion010Result *scannernodeversion010.ScannerNodeVersionAccessManagerUpdatedIterator

	Scannernodeversion011Result *scannernodeversion011.ScannerNodeVersionAccessManagerUpdatedIterator

}

// FilterAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) FilterAccessManagerUpdated(opts *bind.FilterOpts, newAddressManager []common.Address) (retVal *FilterAccessManagerUpdatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterAccessManagerUpdatedOutput{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterAccessManagerUpdated(opts, newAddressManager)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Scannernodeversion010Result = val


		return
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.FilterAccessManagerUpdated(opts, newAddressManager)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Scannernodeversion011Result = val


		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.FilterAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) WatchAccessManagerUpdated(opts *bind.WatchOpts, sink chan<- *scannernodeversion010.ScannerNodeVersionAccessManagerUpdated, newAddressManager []common.Address, sinkAlt1 chan<- *scannernodeversion011.ScannerNodeVersionAccessManagerUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchAccessManagerUpdated(opts, sink, newAddressManager)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.WatchAccessManagerUpdated(opts, sinkAlt1, newAddressManager)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.WatchAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerNodeVersionAccessManagerUpdated is a merged return type.
type ScannerNodeVersionAccessManagerUpdated struct {

	NewAddressManager common.Address

	Raw types.Log

}

// ParseAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) ParseAccessManagerUpdated(log types.Log) (retVal *ScannerNodeVersionAccessManagerUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerNodeVersionAccessManagerUpdated{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseAccessManagerUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.NewAddressManager = val.NewAddressManager

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.ParseAccessManagerUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.NewAddressManager = val.NewAddressManager

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.ParseAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// FilterAdminChangedOutput is a merged return type.
type FilterAdminChangedOutput struct {

	Scannernodeversion010Result *scannernodeversion010.ScannerNodeVersionAdminChangedIterator

	Scannernodeversion011Result *scannernodeversion011.ScannerNodeVersionAdminChangedIterator

}

// FilterAdminChanged multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) FilterAdminChanged(opts *bind.FilterOpts) (retVal *FilterAdminChangedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterAdminChangedOutput{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterAdminChanged(opts)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Scannernodeversion010Result = val


		return
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.FilterAdminChanged(opts)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Scannernodeversion011Result = val


		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.FilterAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}



// WatchAdminChanged multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) WatchAdminChanged(opts *bind.WatchOpts, sink chan<- *scannernodeversion010.ScannerNodeVersionAdminChanged, sinkAlt2 chan<- *scannernodeversion011.ScannerNodeVersionAdminChanged) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchAdminChanged(opts, sink)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.WatchAdminChanged(opts, sinkAlt2)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.WatchAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerNodeVersionAdminChanged is a merged return type.
type ScannerNodeVersionAdminChanged struct {

	PreviousAdmin common.Address

	NewAdmin common.Address

	Raw types.Log

}

// ParseAdminChanged multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) ParseAdminChanged(log types.Log) (retVal *ScannerNodeVersionAdminChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerNodeVersionAdminChanged{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseAdminChanged(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.ParseAdminChanged(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.ParseAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}


// FilterBeaconUpgradedOutput is a merged return type.
type FilterBeaconUpgradedOutput struct {

	Scannernodeversion010Result *scannernodeversion010.ScannerNodeVersionBeaconUpgradedIterator

	Scannernodeversion011Result *scannernodeversion011.ScannerNodeVersionBeaconUpgradedIterator

}

// FilterBeaconUpgraded multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) FilterBeaconUpgraded(opts *bind.FilterOpts, beacon []common.Address) (retVal *FilterBeaconUpgradedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterBeaconUpgradedOutput{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterBeaconUpgraded(opts, beacon)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Scannernodeversion010Result = val


		return
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.FilterBeaconUpgraded(opts, beacon)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Scannernodeversion011Result = val


		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.FilterBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// WatchBeaconUpgraded multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) WatchBeaconUpgraded(opts *bind.WatchOpts, sink chan<- *scannernodeversion010.ScannerNodeVersionBeaconUpgraded, beacon []common.Address, sinkAlt3 chan<- *scannernodeversion011.ScannerNodeVersionBeaconUpgraded) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchBeaconUpgraded(opts, sink, beacon)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.WatchBeaconUpgraded(opts, sinkAlt3, beacon)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.WatchBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerNodeVersionBeaconUpgraded is a merged return type.
type ScannerNodeVersionBeaconUpgraded struct {

	Beacon common.Address

	Raw types.Log

}

// ParseBeaconUpgraded multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) ParseBeaconUpgraded(log types.Log) (retVal *ScannerNodeVersionBeaconUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerNodeVersionBeaconUpgraded{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseBeaconUpgraded(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.ParseBeaconUpgraded(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.ParseBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// FilterRouterUpdatedOutput is a merged return type.
type FilterRouterUpdatedOutput struct {

	Scannernodeversion010Result *scannernodeversion010.ScannerNodeVersionRouterUpdatedIterator

	Scannernodeversion011Result *scannernodeversion011.ScannerNodeVersionRouterUpdatedIterator

}

// FilterRouterUpdated multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) FilterRouterUpdated(opts *bind.FilterOpts, router []common.Address) (retVal *FilterRouterUpdatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterRouterUpdatedOutput{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterRouterUpdated(opts, router)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Scannernodeversion010Result = val


		return
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.FilterRouterUpdated(opts, router)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Scannernodeversion011Result = val


		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.FilterRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchRouterUpdated multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) WatchRouterUpdated(opts *bind.WatchOpts, sink chan<- *scannernodeversion010.ScannerNodeVersionRouterUpdated, router []common.Address, sinkAlt4 chan<- *scannernodeversion011.ScannerNodeVersionRouterUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchRouterUpdated(opts, sink, router)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.WatchRouterUpdated(opts, sinkAlt4, router)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.WatchRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerNodeVersionRouterUpdated is a merged return type.
type ScannerNodeVersionRouterUpdated struct {

	Router common.Address

	Raw types.Log

}

// ParseRouterUpdated multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) ParseRouterUpdated(log types.Log) (retVal *ScannerNodeVersionRouterUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerNodeVersionRouterUpdated{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseRouterUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Router = val.Router

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.ParseRouterUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Router = val.Router

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.ParseRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// FilterScannerNodeVersionUpdatedOutput is a merged return type.
type FilterScannerNodeVersionUpdatedOutput struct {

	Scannernodeversion010Result *scannernodeversion010.ScannerNodeVersionScannerNodeVersionUpdatedIterator

	Scannernodeversion011Result *scannernodeversion011.ScannerNodeVersionScannerNodeVersionUpdatedIterator

}

// FilterScannerNodeVersionUpdated multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) FilterScannerNodeVersionUpdated(opts *bind.FilterOpts) (retVal *FilterScannerNodeVersionUpdatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterScannerNodeVersionUpdatedOutput{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterScannerNodeVersionUpdated(opts)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Scannernodeversion010Result = val


		return
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.FilterScannerNodeVersionUpdated(opts)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Scannernodeversion011Result = val


		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.FilterScannerNodeVersionUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchScannerNodeVersionUpdated multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) WatchScannerNodeVersionUpdated(opts *bind.WatchOpts, sink chan<- *scannernodeversion010.ScannerNodeVersionScannerNodeVersionUpdated, sinkAlt5 chan<- *scannernodeversion011.ScannerNodeVersionScannerNodeVersionUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchScannerNodeVersionUpdated(opts, sink)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.WatchScannerNodeVersionUpdated(opts, sinkAlt5)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.WatchScannerNodeVersionUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerNodeVersionScannerNodeVersionUpdated is a merged return type.
type ScannerNodeVersionScannerNodeVersionUpdated struct {

	NewVersion string

	OldVersion string

	Raw types.Log

}

// ParseScannerNodeVersionUpdated multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) ParseScannerNodeVersionUpdated(log types.Log) (retVal *ScannerNodeVersionScannerNodeVersionUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerNodeVersionScannerNodeVersionUpdated{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseScannerNodeVersionUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.NewVersion = val.NewVersion

		retVal.OldVersion = val.OldVersion

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.ParseScannerNodeVersionUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.NewVersion = val.NewVersion

		retVal.OldVersion = val.OldVersion

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.ParseScannerNodeVersionUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// FilterUpgradedOutput is a merged return type.
type FilterUpgradedOutput struct {

	Scannernodeversion010Result *scannernodeversion010.ScannerNodeVersionUpgradedIterator

	Scannernodeversion011Result *scannernodeversion011.ScannerNodeVersionUpgradedIterator

}

// FilterUpgraded multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) FilterUpgraded(opts *bind.FilterOpts, implementation []common.Address) (retVal *FilterUpgradedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterUpgradedOutput{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterUpgraded(opts, implementation)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Scannernodeversion010Result = val


		return
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.FilterUpgraded(opts, implementation)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Scannernodeversion011Result = val


		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.FilterUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// WatchUpgraded multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) WatchUpgraded(opts *bind.WatchOpts, sink chan<- *scannernodeversion010.ScannerNodeVersionUpgraded, implementation []common.Address, sinkAlt6 chan<- *scannernodeversion011.ScannerNodeVersionUpgraded) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchUpgraded(opts, sink, implementation)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.WatchUpgraded(opts, sinkAlt6, implementation)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.WatchUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerNodeVersionUpgraded is a merged return type.
type ScannerNodeVersionUpgraded struct {

	Implementation common.Address

	Raw types.Log

}

// ParseUpgraded multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) ParseUpgraded(log types.Log) (retVal *ScannerNodeVersionUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerNodeVersionUpgraded{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseUpgraded(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.ParseUpgraded(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.ParseUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// FilterInitialized multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) FilterInitialized(opts *bind.FilterOpts) (retVal *scannernodeversion011.ScannerNodeVersionInitializedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.FilterInitialized(opts)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.FilterInitialized not implemented (tag=%s)", merged.currTag)
	return
}



// WatchInitialized multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *scannernodeversion011.ScannerNodeVersionInitialized) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.WatchInitialized(opts, sink)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.WatchInitialized not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerNodeVersionInitialized is a merged return type.
type ScannerNodeVersionInitialized struct {

	Version uint8

	Raw types.Log

}

// ParseInitialized multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) ParseInitialized(log types.Log) (retVal *ScannerNodeVersionInitialized, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerNodeVersionInitialized{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.ParseInitialized(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Version = val.Version

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.ParseInitialized not implemented (tag=%s)", merged.currTag)
	return
}



// FilterScannerNodeBetaVersionUpdated multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) FilterScannerNodeBetaVersionUpdated(opts *bind.FilterOpts) (retVal *scannernodeversion011.ScannerNodeVersionScannerNodeBetaVersionUpdatedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.FilterScannerNodeBetaVersionUpdated(opts)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.FilterScannerNodeBetaVersionUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchScannerNodeBetaVersionUpdated multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) WatchScannerNodeBetaVersionUpdated(opts *bind.WatchOpts, sink chan<- *scannernodeversion011.ScannerNodeVersionScannerNodeBetaVersionUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.WatchScannerNodeBetaVersionUpdated(opts, sink)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.WatchScannerNodeBetaVersionUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerNodeVersionScannerNodeBetaVersionUpdated is a merged return type.
type ScannerNodeVersionScannerNodeBetaVersionUpdated struct {

	NewVersion string

	OldVersion string

	Raw types.Log

}

// ParseScannerNodeBetaVersionUpdated multiplexes to different implementations of the method.
func (merged *ScannerNodeVersionFilterer) ParseScannerNodeBetaVersionUpdated(log types.Log) (retVal *ScannerNodeVersionScannerNodeBetaVersionUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerNodeVersionScannerNodeBetaVersionUpdated{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ1.ParseScannerNodeBetaVersionUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.NewVersion = val.NewVersion

		retVal.OldVersion = val.OldVersion

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerNodeVersionFilterer.ParseScannerNodeBetaVersionUpdated not implemented (tag=%s)", merged.currTag)
	return
}