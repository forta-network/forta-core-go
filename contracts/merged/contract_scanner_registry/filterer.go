// Code generated by go-merge-types. DO NOT EDIT.

package contract_scanner_registry

import (
	import_fmt "fmt"
	import_sync "sync"


	scannerregistry013 "github.com/forta-network/forta-core-go/contracts/generated/contract_scanner_registry_0_1_3"

	scannerregistry014 "github.com/forta-network/forta-core-go/contracts/generated/contract_scanner_registry_0_1_4"



	"github.com/ethereum/go-ethereum/accounts/abi/bind"

	"github.com/ethereum/go-ethereum/event"

	"github.com/ethereum/go-ethereum/core/types"

	"github.com/ethereum/go-ethereum/common"

	"math/big"

)

// ScannerRegistryFilterer is a new type which can multiplex calls to different implementation types.
type ScannerRegistryFilterer struct {

	typ0 *scannerregistry013.ScannerRegistryFilterer

	typ1 *scannerregistry014.ScannerRegistryFilterer

	currTag string
	mu import_sync.RWMutex
	unsafe bool // default: false
}

// NewScannerRegistryFilterer creates a new merged type.
func NewScannerRegistryFilterer(address common.Address, filterer bind.ContractFilterer) (*ScannerRegistryFilterer, error) {
	var (
		mergedType ScannerRegistryFilterer
		err error
	)
	mergedType.currTag = "0.1.4"


	mergedType.typ0, err = scannerregistry013.NewScannerRegistryFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize scannerregistry013.ScannerRegistryFilterer: %v", err)
	}

	mergedType.typ1, err = scannerregistry014.NewScannerRegistryFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize scannerregistry014.ScannerRegistryFilterer: %v", err)
	}


	return &mergedType, nil
}

// IsKnownTagForScannerRegistryFilterer tells if given tag is a known tag.
func IsKnownTagForScannerRegistryFilterer(tag string) bool {

	if tag == "0.1.3" {
		return true
	}

	if tag == "0.1.4" {
		return true
	}

	return false
}

// Use sets the used implementation to given tag.
func (merged *ScannerRegistryFilterer) Use(tag string) (changed bool) {
	if !merged.unsafe {
		merged.mu.Lock()
		defer merged.mu.Unlock()
	}
	// use the default tag if the provided tag is unknown
	if !IsKnownTagForScannerRegistryFilterer(tag) {
		tag = "0.1.4"
	}
	changed = merged.currTag != tag
	merged.currTag = tag
	return
}

// Unsafe disables the mutex.
func (merged *ScannerRegistryFilterer) Unsafe() {
	merged.unsafe = true
}

// Safe enables the mutex.
func (merged *ScannerRegistryFilterer) Safe() {
	merged.unsafe = false
}



// FilterAccessManagerUpdatedOutput is a merged return type.
type FilterAccessManagerUpdatedOutput struct {

	Scannerregistry013Result *scannerregistry013.ScannerRegistryAccessManagerUpdatedIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryAccessManagerUpdatedIterator

}

// FilterAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterAccessManagerUpdated(opts *bind.FilterOpts, newAddressManager []common.Address) (retVal *FilterAccessManagerUpdatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterAccessManagerUpdatedOutput{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterAccessManagerUpdated(opts, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry013Result = val


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterAccessManagerUpdated(opts, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry014Result = val


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchAccessManagerUpdated(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryAccessManagerUpdated, newAddressManager []common.Address, sinkAlt1 chan<- *scannerregistry014.ScannerRegistryAccessManagerUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchAccessManagerUpdated(opts, sink, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchAccessManagerUpdated(opts, sinkAlt1, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerRegistryAccessManagerUpdated is a merged return type.
type ScannerRegistryAccessManagerUpdated struct {

	NewAddressManager common.Address

	Raw types.Log

}

// ParseAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseAccessManagerUpdated(log types.Log) (retVal *ScannerRegistryAccessManagerUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerRegistryAccessManagerUpdated{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseAccessManagerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.NewAddressManager = val.NewAddressManager

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseAccessManagerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.NewAddressManager = val.NewAddressManager

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// FilterAdminChangedOutput is a merged return type.
type FilterAdminChangedOutput struct {

	Scannerregistry013Result *scannerregistry013.ScannerRegistryAdminChangedIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryAdminChangedIterator

}

// FilterAdminChanged multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterAdminChanged(opts *bind.FilterOpts) (retVal *FilterAdminChangedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterAdminChangedOutput{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterAdminChanged(opts)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry013Result = val


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterAdminChanged(opts)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry014Result = val


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}



// WatchAdminChanged multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchAdminChanged(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryAdminChanged, sinkAlt2 chan<- *scannerregistry014.ScannerRegistryAdminChanged) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchAdminChanged(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchAdminChanged(opts, sinkAlt2)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerRegistryAdminChanged is a merged return type.
type ScannerRegistryAdminChanged struct {

	PreviousAdmin common.Address

	NewAdmin common.Address

	Raw types.Log

}

// ParseAdminChanged multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseAdminChanged(log types.Log) (retVal *ScannerRegistryAdminChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerRegistryAdminChanged{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseAdminChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseAdminChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}


// FilterApprovalOutput is a merged return type.
type FilterApprovalOutput struct {

	Scannerregistry013Result *scannerregistry013.ScannerRegistryApprovalIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryApprovalIterator

}

// FilterApproval multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (retVal *FilterApprovalOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterApprovalOutput{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterApproval(opts, owner, approved, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry013Result = val


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterApproval(opts, owner, approved, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry014Result = val


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterApproval not implemented (tag=%s)", merged.currTag)
	return
}



// WatchApproval multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryApproval, owner []common.Address, approved []common.Address, tokenId []*big.Int, sinkAlt3 chan<- *scannerregistry014.ScannerRegistryApproval) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchApproval(opts, sink, owner, approved, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchApproval(opts, sinkAlt3, owner, approved, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchApproval not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerRegistryApproval is a merged return type.
type ScannerRegistryApproval struct {

	Owner common.Address

	Approved common.Address

	TokenId *big.Int

	Raw types.Log

}

// ParseApproval multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseApproval(log types.Log) (retVal *ScannerRegistryApproval, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerRegistryApproval{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseApproval(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Owner = val.Owner

		retVal.Approved = val.Approved

		retVal.TokenId = val.TokenId

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseApproval(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Owner = val.Owner

		retVal.Approved = val.Approved

		retVal.TokenId = val.TokenId

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseApproval not implemented (tag=%s)", merged.currTag)
	return
}


// FilterApprovalForAllOutput is a merged return type.
type FilterApprovalForAllOutput struct {

	Scannerregistry013Result *scannerregistry013.ScannerRegistryApprovalForAllIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryApprovalForAllIterator

}

// FilterApprovalForAll multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (retVal *FilterApprovalForAllOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterApprovalForAllOutput{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterApprovalForAll(opts, owner, operator)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry013Result = val


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterApprovalForAll(opts, owner, operator)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry014Result = val


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}



// WatchApprovalForAll multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryApprovalForAll, owner []common.Address, operator []common.Address, sinkAlt4 chan<- *scannerregistry014.ScannerRegistryApprovalForAll) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchApprovalForAll(opts, sink, owner, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchApprovalForAll(opts, sinkAlt4, owner, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerRegistryApprovalForAll is a merged return type.
type ScannerRegistryApprovalForAll struct {

	Owner common.Address

	Operator common.Address

	Approved bool

	Raw types.Log

}

// ParseApprovalForAll multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseApprovalForAll(log types.Log) (retVal *ScannerRegistryApprovalForAll, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerRegistryApprovalForAll{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseApprovalForAll(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Owner = val.Owner

		retVal.Operator = val.Operator

		retVal.Approved = val.Approved

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseApprovalForAll(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Owner = val.Owner

		retVal.Operator = val.Operator

		retVal.Approved = val.Approved

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}


// FilterBeaconUpgradedOutput is a merged return type.
type FilterBeaconUpgradedOutput struct {

	Scannerregistry013Result *scannerregistry013.ScannerRegistryBeaconUpgradedIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryBeaconUpgradedIterator

}

// FilterBeaconUpgraded multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterBeaconUpgraded(opts *bind.FilterOpts, beacon []common.Address) (retVal *FilterBeaconUpgradedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterBeaconUpgradedOutput{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterBeaconUpgraded(opts, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry013Result = val


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterBeaconUpgraded(opts, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry014Result = val


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// WatchBeaconUpgraded multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchBeaconUpgraded(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryBeaconUpgraded, beacon []common.Address, sinkAlt5 chan<- *scannerregistry014.ScannerRegistryBeaconUpgraded) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchBeaconUpgraded(opts, sink, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchBeaconUpgraded(opts, sinkAlt5, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerRegistryBeaconUpgraded is a merged return type.
type ScannerRegistryBeaconUpgraded struct {

	Beacon common.Address

	Raw types.Log

}

// ParseBeaconUpgraded multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseBeaconUpgraded(log types.Log) (retVal *ScannerRegistryBeaconUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerRegistryBeaconUpgraded{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseBeaconUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseBeaconUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// FilterInitializedOutput is a merged return type.
type FilterInitializedOutput struct {

	Scannerregistry013Result *scannerregistry013.ScannerRegistryInitializedIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryInitializedIterator

}

// FilterInitialized multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterInitialized(opts *bind.FilterOpts) (retVal *FilterInitializedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterInitializedOutput{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterInitialized(opts)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry013Result = val


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterInitialized(opts)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry014Result = val


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterInitialized not implemented (tag=%s)", merged.currTag)
	return
}



// WatchInitialized multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryInitialized, sinkAlt6 chan<- *scannerregistry014.ScannerRegistryInitialized) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchInitialized(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchInitialized(opts, sinkAlt6)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchInitialized not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerRegistryInitialized is a merged return type.
type ScannerRegistryInitialized struct {

	Version uint8

	Raw types.Log

}

// ParseInitialized multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseInitialized(log types.Log) (retVal *ScannerRegistryInitialized, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerRegistryInitialized{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseInitialized(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Version = val.Version

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseInitialized(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Version = val.Version

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseInitialized not implemented (tag=%s)", merged.currTag)
	return
}


// FilterManagerEnabledOutput is a merged return type.
type FilterManagerEnabledOutput struct {

	Scannerregistry013Result *scannerregistry013.ScannerRegistryManagerEnabledIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryManagerEnabledIterator

}

// FilterManagerEnabled multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterManagerEnabled(opts *bind.FilterOpts, scannerId []*big.Int, manager []common.Address) (retVal *FilterManagerEnabledOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterManagerEnabledOutput{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterManagerEnabled(opts, scannerId, manager)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry013Result = val


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterManagerEnabled(opts, scannerId, manager)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry014Result = val


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterManagerEnabled not implemented (tag=%s)", merged.currTag)
	return
}



// WatchManagerEnabled multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchManagerEnabled(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryManagerEnabled, scannerId []*big.Int, manager []common.Address, sinkAlt7 chan<- *scannerregistry014.ScannerRegistryManagerEnabled) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchManagerEnabled(opts, sink, scannerId, manager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchManagerEnabled(opts, sinkAlt7, scannerId, manager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchManagerEnabled not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerRegistryManagerEnabled is a merged return type.
type ScannerRegistryManagerEnabled struct {

	ScannerId *big.Int

	Manager common.Address

	Enabled bool

	Raw types.Log

}

// ParseManagerEnabled multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseManagerEnabled(log types.Log) (retVal *ScannerRegistryManagerEnabled, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerRegistryManagerEnabled{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseManagerEnabled(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.ScannerId = val.ScannerId

		retVal.Manager = val.Manager

		retVal.Enabled = val.Enabled

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseManagerEnabled(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.ScannerId = val.ScannerId

		retVal.Manager = val.Manager

		retVal.Enabled = val.Enabled

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseManagerEnabled not implemented (tag=%s)", merged.currTag)
	return
}


// FilterRouterUpdatedOutput is a merged return type.
type FilterRouterUpdatedOutput struct {

	Scannerregistry013Result *scannerregistry013.ScannerRegistryRouterUpdatedIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryRouterUpdatedIterator

}

// FilterRouterUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterRouterUpdated(opts *bind.FilterOpts, router []common.Address) (retVal *FilterRouterUpdatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterRouterUpdatedOutput{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterRouterUpdated(opts, router)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry013Result = val


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterRouterUpdated(opts, router)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry014Result = val


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchRouterUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchRouterUpdated(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryRouterUpdated, router []common.Address, sinkAlt8 chan<- *scannerregistry014.ScannerRegistryRouterUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchRouterUpdated(opts, sink, router)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchRouterUpdated(opts, sinkAlt8, router)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerRegistryRouterUpdated is a merged return type.
type ScannerRegistryRouterUpdated struct {

	Router common.Address

	Raw types.Log

}

// ParseRouterUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseRouterUpdated(log types.Log) (retVal *ScannerRegistryRouterUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerRegistryRouterUpdated{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseRouterUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Router = val.Router

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseRouterUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Router = val.Router

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// FilterScannerEnabledOutput is a merged return type.
type FilterScannerEnabledOutput struct {

	Scannerregistry013Result *scannerregistry013.ScannerRegistryScannerEnabledIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryScannerEnabledIterator

}

// FilterScannerEnabled multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterScannerEnabled(opts *bind.FilterOpts, scannerId []*big.Int, enabled []bool) (retVal *FilterScannerEnabledOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterScannerEnabledOutput{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterScannerEnabled(opts, scannerId, enabled)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry013Result = val


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterScannerEnabled(opts, scannerId, enabled)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry014Result = val


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterScannerEnabled not implemented (tag=%s)", merged.currTag)
	return
}



// WatchScannerEnabled multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchScannerEnabled(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryScannerEnabled, scannerId []*big.Int, enabled []bool, sinkAlt9 chan<- *scannerregistry014.ScannerRegistryScannerEnabled) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchScannerEnabled(opts, sink, scannerId, enabled)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchScannerEnabled(opts, sinkAlt9, scannerId, enabled)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchScannerEnabled not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerRegistryScannerEnabled is a merged return type.
type ScannerRegistryScannerEnabled struct {

	ScannerId *big.Int

	Enabled bool

	Permission uint8

	Value bool

	Raw types.Log

}

// ParseScannerEnabled multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseScannerEnabled(log types.Log) (retVal *ScannerRegistryScannerEnabled, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerRegistryScannerEnabled{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseScannerEnabled(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.ScannerId = val.ScannerId

		retVal.Enabled = val.Enabled

		retVal.Permission = val.Permission

		retVal.Value = val.Value

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseScannerEnabled(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.ScannerId = val.ScannerId

		retVal.Enabled = val.Enabled

		retVal.Permission = val.Permission

		retVal.Value = val.Value

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseScannerEnabled not implemented (tag=%s)", merged.currTag)
	return
}


// FilterScannerUpdatedOutput is a merged return type.
type FilterScannerUpdatedOutput struct {

	Scannerregistry013Result *scannerregistry013.ScannerRegistryScannerUpdatedIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryScannerUpdatedIterator

}

// FilterScannerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterScannerUpdated(opts *bind.FilterOpts, scannerId []*big.Int, chainId []*big.Int) (retVal *FilterScannerUpdatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterScannerUpdatedOutput{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterScannerUpdated(opts, scannerId, chainId)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry013Result = val


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterScannerUpdated(opts, scannerId, chainId)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry014Result = val


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterScannerUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchScannerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchScannerUpdated(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryScannerUpdated, scannerId []*big.Int, chainId []*big.Int, sinkAlt10 chan<- *scannerregistry014.ScannerRegistryScannerUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchScannerUpdated(opts, sink, scannerId, chainId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchScannerUpdated(opts, sinkAlt10, scannerId, chainId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchScannerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerRegistryScannerUpdated is a merged return type.
type ScannerRegistryScannerUpdated struct {

	ScannerId *big.Int

	ChainId *big.Int

	Metadata string

	Raw types.Log

}

// ParseScannerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseScannerUpdated(log types.Log) (retVal *ScannerRegistryScannerUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerRegistryScannerUpdated{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseScannerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.ScannerId = val.ScannerId

		retVal.ChainId = val.ChainId

		retVal.Metadata = val.Metadata

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseScannerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.ScannerId = val.ScannerId

		retVal.ChainId = val.ChainId

		retVal.Metadata = val.Metadata

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseScannerUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// FilterStakeControllerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterStakeControllerUpdated(opts *bind.FilterOpts, newstakeController []common.Address) (retVal *scannerregistry013.ScannerRegistryStakeControllerUpdatedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterStakeControllerUpdated(opts, newstakeController)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterStakeControllerUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchStakeControllerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchStakeControllerUpdated(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryStakeControllerUpdated, newstakeController []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchStakeControllerUpdated(opts, sink, newstakeController)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchStakeControllerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerRegistryStakeControllerUpdated is a merged return type.
type ScannerRegistryStakeControllerUpdated struct {

	NewstakeController common.Address

	Raw types.Log

}

// ParseStakeControllerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseStakeControllerUpdated(log types.Log) (retVal *ScannerRegistryStakeControllerUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerRegistryStakeControllerUpdated{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseStakeControllerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.NewstakeController = val.NewstakeController

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseStakeControllerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// FilterStakeThresholdChangedOutput is a merged return type.
type FilterStakeThresholdChangedOutput struct {

	Scannerregistry013Result *scannerregistry013.ScannerRegistryStakeThresholdChangedIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryStakeThresholdChangedIterator

}

// FilterStakeThresholdChanged multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterStakeThresholdChanged(opts *bind.FilterOpts, chainId []*big.Int) (retVal *FilterStakeThresholdChangedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterStakeThresholdChangedOutput{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterStakeThresholdChanged(opts, chainId)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry013Result = val


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterStakeThresholdChanged(opts, chainId)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry014Result = val


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterStakeThresholdChanged not implemented (tag=%s)", merged.currTag)
	return
}



// WatchStakeThresholdChanged multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchStakeThresholdChanged(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryStakeThresholdChanged, chainId []*big.Int, sinkAlt11 chan<- *scannerregistry014.ScannerRegistryStakeThresholdChanged) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchStakeThresholdChanged(opts, sink, chainId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchStakeThresholdChanged(opts, sinkAlt11, chainId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchStakeThresholdChanged not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerRegistryStakeThresholdChanged is a merged return type.
type ScannerRegistryStakeThresholdChanged struct {

	ChainId *big.Int

	Min *big.Int

	Max *big.Int

	Activated bool

	Raw types.Log

}

// ParseStakeThresholdChanged multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseStakeThresholdChanged(log types.Log) (retVal *ScannerRegistryStakeThresholdChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerRegistryStakeThresholdChanged{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseStakeThresholdChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.ChainId = val.ChainId

		retVal.Min = val.Min

		retVal.Max = val.Max

		retVal.Activated = val.Activated

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseStakeThresholdChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.ChainId = val.ChainId

		retVal.Min = val.Min

		retVal.Max = val.Max

		retVal.Activated = val.Activated

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseStakeThresholdChanged not implemented (tag=%s)", merged.currTag)
	return
}


// FilterTransferOutput is a merged return type.
type FilterTransferOutput struct {

	Scannerregistry013Result *scannerregistry013.ScannerRegistryTransferIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryTransferIterator

}

// FilterTransfer multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (retVal *FilterTransferOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterTransferOutput{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterTransfer(opts, from, to, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry013Result = val


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterTransfer(opts, from, to, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry014Result = val


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterTransfer not implemented (tag=%s)", merged.currTag)
	return
}



// WatchTransfer multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryTransfer, from []common.Address, to []common.Address, tokenId []*big.Int, sinkAlt12 chan<- *scannerregistry014.ScannerRegistryTransfer) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchTransfer(opts, sink, from, to, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchTransfer(opts, sinkAlt12, from, to, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchTransfer not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerRegistryTransfer is a merged return type.
type ScannerRegistryTransfer struct {

	From common.Address

	To common.Address

	TokenId *big.Int

	Raw types.Log

}

// ParseTransfer multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseTransfer(log types.Log) (retVal *ScannerRegistryTransfer, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerRegistryTransfer{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseTransfer(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.From = val.From

		retVal.To = val.To

		retVal.TokenId = val.TokenId

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseTransfer(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.From = val.From

		retVal.To = val.To

		retVal.TokenId = val.TokenId

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseTransfer not implemented (tag=%s)", merged.currTag)
	return
}


// FilterUpgradedOutput is a merged return type.
type FilterUpgradedOutput struct {

	Scannerregistry013Result *scannerregistry013.ScannerRegistryUpgradedIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryUpgradedIterator

}

// FilterUpgraded multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterUpgraded(opts *bind.FilterOpts, implementation []common.Address) (retVal *FilterUpgradedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterUpgradedOutput{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterUpgraded(opts, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry013Result = val


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterUpgraded(opts, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Scannerregistry014Result = val


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// WatchUpgraded multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchUpgraded(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryUpgraded, implementation []common.Address, sinkAlt13 chan<- *scannerregistry014.ScannerRegistryUpgraded) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchUpgraded(opts, sink, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchUpgraded(opts, sinkAlt13, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerRegistryUpgraded is a merged return type.
type ScannerRegistryUpgraded struct {

	Implementation common.Address

	Raw types.Log

}

// ParseUpgraded multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseUpgraded(log types.Log) (retVal *ScannerRegistryUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerRegistryUpgraded{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// FilterConfiguredMigration multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterConfiguredMigration(opts *bind.FilterOpts) (retVal *scannerregistry014.ScannerRegistryConfiguredMigrationIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterConfiguredMigration(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterConfiguredMigration not implemented (tag=%s)", merged.currTag)
	return
}



// WatchConfiguredMigration multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchConfiguredMigration(opts *bind.WatchOpts, sink chan<- *scannerregistry014.ScannerRegistryConfiguredMigration) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchConfiguredMigration(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchConfiguredMigration not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerRegistryConfiguredMigration is a merged return type.
type ScannerRegistryConfiguredMigration struct {

	SunsettingTime *big.Int

	ScannerPoolRegistry common.Address

	Raw types.Log

}

// ParseConfiguredMigration multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseConfiguredMigration(log types.Log) (retVal *ScannerRegistryConfiguredMigration, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerRegistryConfiguredMigration{}



	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseConfiguredMigration(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.SunsettingTime = val.SunsettingTime

		retVal.ScannerPoolRegistry = val.ScannerPoolRegistry

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseConfiguredMigration not implemented (tag=%s)", merged.currTag)
	return
}



// FilterDeregisteredScanner multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterDeregisteredScanner(opts *bind.FilterOpts) (retVal *scannerregistry014.ScannerRegistryDeregisteredScannerIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterDeregisteredScanner(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterDeregisteredScanner not implemented (tag=%s)", merged.currTag)
	return
}



// WatchDeregisteredScanner multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchDeregisteredScanner(opts *bind.WatchOpts, sink chan<- *scannerregistry014.ScannerRegistryDeregisteredScanner) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchDeregisteredScanner(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchDeregisteredScanner not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerRegistryDeregisteredScanner is a merged return type.
type ScannerRegistryDeregisteredScanner struct {

	ScannerId *big.Int

	Raw types.Log

}

// ParseDeregisteredScanner multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseDeregisteredScanner(log types.Log) (retVal *ScannerRegistryDeregisteredScanner, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerRegistryDeregisteredScanner{}



	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseDeregisteredScanner(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.ScannerId = val.ScannerId

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseDeregisteredScanner not implemented (tag=%s)", merged.currTag)
	return
}



// FilterSubjectHandlerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterSubjectHandlerUpdated(opts *bind.FilterOpts, newHandler []common.Address) (retVal *scannerregistry014.ScannerRegistrySubjectHandlerUpdatedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterSubjectHandlerUpdated(opts, newHandler)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterSubjectHandlerUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchSubjectHandlerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchSubjectHandlerUpdated(opts *bind.WatchOpts, sink chan<- *scannerregistry014.ScannerRegistrySubjectHandlerUpdated, newHandler []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchSubjectHandlerUpdated(opts, sink, newHandler)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchSubjectHandlerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// ScannerRegistrySubjectHandlerUpdated is a merged return type.
type ScannerRegistrySubjectHandlerUpdated struct {

	NewHandler common.Address

	Raw types.Log

}

// ParseSubjectHandlerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseSubjectHandlerUpdated(log types.Log) (retVal *ScannerRegistrySubjectHandlerUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &ScannerRegistrySubjectHandlerUpdated{}



	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseSubjectHandlerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.NewHandler = val.NewHandler

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseSubjectHandlerUpdated not implemented (tag=%s)", merged.currTag)
	return
}