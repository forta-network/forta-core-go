// Code generated by go-merge-types. DO NOT EDIT.

package contract_scanner_registry

import (
	import_fmt "fmt"
	import_sync "sync"

	scannerregistry013 "github.com/forta-network/forta-core-go/contracts/generated/contract_scanner_registry_0_1_3"

	scannerregistry014 "github.com/forta-network/forta-core-go/contracts/generated/contract_scanner_registry_0_1_4"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"

	"github.com/ethereum/go-ethereum/event"

	"github.com/ethereum/go-ethereum/core/types"

	"github.com/ethereum/go-ethereum/common"

	"math/big"
)

// ScannerRegistryFilterer is a new type which can multiplex calls to different implementation types.
type ScannerRegistryFilterer struct {
	typ0 *scannerregistry013.ScannerRegistryFilterer

	typ1 *scannerregistry014.ScannerRegistryFilterer

	currTag string
	mu      import_sync.RWMutex
	unsafe  bool // default: false
}

// NewScannerRegistryFilterer creates a new merged type.
func NewScannerRegistryFilterer(address common.Address, filterer bind.ContractFilterer) (*ScannerRegistryFilterer, error) {
	var (
		mergedType ScannerRegistryFilterer
		err        error
	)
	mergedType.currTag = "0.1.3"

	mergedType.typ0, err = scannerregistry013.NewScannerRegistryFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize scannerregistry013.ScannerRegistryFilterer: %v", err)
	}

	mergedType.typ1, err = scannerregistry014.NewScannerRegistryFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize scannerregistry014.ScannerRegistryFilterer: %v", err)
	}

	return &mergedType, nil
}

// IsKnownTagForScannerRegistryFilterer tells if given tag is a known tag.
func IsKnownTagForScannerRegistryFilterer(tag string) bool {

	if tag == "0.1.3" {
		return true
	}

	if tag == "0.1.4" {
		return true
	}

	return false
}

// Use sets the used implementation to given tag.
func (merged *ScannerRegistryFilterer) Use(tag string) (changed bool) {
	if !merged.unsafe {
		merged.mu.Lock()
		defer merged.mu.Unlock()
	}
	// use the default tag if the provided tag is unknown
	if !IsKnownTagForScannerRegistryFilterer(tag) {
		tag = "0.1.3"
	}
	changed = merged.currTag != tag
	merged.currTag = tag
	return
}

// Unsafe disables the mutex.
func (merged *ScannerRegistryFilterer) Unsafe() {
	merged.unsafe = true
}

// Safe enables the mutex.
func (merged *ScannerRegistryFilterer) Safe() {
	merged.unsafe = false
}

// FilterAccessManagerUpdatedOutput is a merged return type.
type FilterAccessManagerUpdatedOutput struct {
	Scannerregistry013Result *scannerregistry013.ScannerRegistryAccessManagerUpdatedIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryAccessManagerUpdatedIterator
}

// FilterAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterAccessManagerUpdated(opts *bind.FilterOpts, newAddressManager []common.Address) (retVal *FilterAccessManagerUpdatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterAccessManagerUpdatedOutput{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterAccessManagerUpdated(opts, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry013Result = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterAccessManagerUpdated(opts, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry014Result = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// WatchAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchAccessManagerUpdated(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryAccessManagerUpdated, newAddressManager []common.Address, sinkAlt1 chan<- *scannerregistry014.ScannerRegistryAccessManagerUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchAccessManagerUpdated(opts, sink, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchAccessManagerUpdated(opts, sinkAlt1, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerRegistryAccessManagerUpdated is a merged return type.
type ScannerRegistryAccessManagerUpdated struct {
	NewAddressManager common.Address

	Raw types.Log
}

// ParseAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseAccessManagerUpdated(log types.Log) (retVal *ScannerRegistryAccessManagerUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ScannerRegistryAccessManagerUpdated{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseAccessManagerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewAddressManager = val.NewAddressManager

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseAccessManagerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewAddressManager = val.NewAddressManager

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// FilterAdminChangedOutput is a merged return type.
type FilterAdminChangedOutput struct {
	Scannerregistry013Result *scannerregistry013.ScannerRegistryAdminChangedIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryAdminChangedIterator
}

// FilterAdminChanged multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterAdminChanged(opts *bind.FilterOpts) (retVal *FilterAdminChangedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterAdminChangedOutput{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterAdminChanged(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry013Result = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterAdminChanged(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry014Result = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}

// WatchAdminChanged multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchAdminChanged(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryAdminChanged, sinkAlt2 chan<- *scannerregistry014.ScannerRegistryAdminChanged) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchAdminChanged(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchAdminChanged(opts, sinkAlt2)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerRegistryAdminChanged is a merged return type.
type ScannerRegistryAdminChanged struct {
	PreviousAdmin common.Address

	NewAdmin common.Address

	Raw types.Log
}

// ParseAdminChanged multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseAdminChanged(log types.Log) (retVal *ScannerRegistryAdminChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ScannerRegistryAdminChanged{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseAdminChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseAdminChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}

// FilterApprovalOutput is a merged return type.
type FilterApprovalOutput struct {
	Scannerregistry013Result *scannerregistry013.ScannerRegistryApprovalIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryApprovalIterator
}

// FilterApproval multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (retVal *FilterApprovalOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterApprovalOutput{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterApproval(opts, owner, approved, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry013Result = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterApproval(opts, owner, approved, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry014Result = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterApproval not implemented (tag=%s)", merged.currTag)
	return
}

// WatchApproval multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryApproval, owner []common.Address, approved []common.Address, tokenId []*big.Int, sinkAlt3 chan<- *scannerregistry014.ScannerRegistryApproval) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchApproval(opts, sink, owner, approved, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchApproval(opts, sinkAlt3, owner, approved, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchApproval not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerRegistryApproval is a merged return type.
type ScannerRegistryApproval struct {
	Owner common.Address

	Approved common.Address

	TokenId *big.Int

	Raw types.Log
}

// ParseApproval multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseApproval(log types.Log) (retVal *ScannerRegistryApproval, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ScannerRegistryApproval{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseApproval(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Owner = val.Owner

		retVal.Approved = val.Approved

		retVal.TokenId = val.TokenId

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseApproval(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Owner = val.Owner

		retVal.Approved = val.Approved

		retVal.TokenId = val.TokenId

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseApproval not implemented (tag=%s)", merged.currTag)
	return
}

// FilterApprovalForAllOutput is a merged return type.
type FilterApprovalForAllOutput struct {
	Scannerregistry013Result *scannerregistry013.ScannerRegistryApprovalForAllIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryApprovalForAllIterator
}

// FilterApprovalForAll multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (retVal *FilterApprovalForAllOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterApprovalForAllOutput{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterApprovalForAll(opts, owner, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry013Result = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterApprovalForAll(opts, owner, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry014Result = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}

// WatchApprovalForAll multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryApprovalForAll, owner []common.Address, operator []common.Address, sinkAlt4 chan<- *scannerregistry014.ScannerRegistryApprovalForAll) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchApprovalForAll(opts, sink, owner, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchApprovalForAll(opts, sinkAlt4, owner, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerRegistryApprovalForAll is a merged return type.
type ScannerRegistryApprovalForAll struct {
	Owner common.Address

	Operator common.Address

	Approved bool

	Raw types.Log
}

// ParseApprovalForAll multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseApprovalForAll(log types.Log) (retVal *ScannerRegistryApprovalForAll, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ScannerRegistryApprovalForAll{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseApprovalForAll(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Owner = val.Owner

		retVal.Operator = val.Operator

		retVal.Approved = val.Approved

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseApprovalForAll(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Owner = val.Owner

		retVal.Operator = val.Operator

		retVal.Approved = val.Approved

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}

// FilterBeaconUpgradedOutput is a merged return type.
type FilterBeaconUpgradedOutput struct {
	Scannerregistry013Result *scannerregistry013.ScannerRegistryBeaconUpgradedIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryBeaconUpgradedIterator
}

// FilterBeaconUpgraded multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterBeaconUpgraded(opts *bind.FilterOpts, beacon []common.Address) (retVal *FilterBeaconUpgradedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterBeaconUpgradedOutput{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterBeaconUpgraded(opts, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry013Result = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterBeaconUpgraded(opts, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry014Result = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// WatchBeaconUpgraded multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchBeaconUpgraded(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryBeaconUpgraded, beacon []common.Address, sinkAlt5 chan<- *scannerregistry014.ScannerRegistryBeaconUpgraded) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchBeaconUpgraded(opts, sink, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchBeaconUpgraded(opts, sinkAlt5, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerRegistryBeaconUpgraded is a merged return type.
type ScannerRegistryBeaconUpgraded struct {
	Beacon common.Address

	Raw types.Log
}

// ParseBeaconUpgraded multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseBeaconUpgraded(log types.Log) (retVal *ScannerRegistryBeaconUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ScannerRegistryBeaconUpgraded{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseBeaconUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseBeaconUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// FilterInitializedOutput is a merged return type.
type FilterInitializedOutput struct {
	Scannerregistry013Result *scannerregistry013.ScannerRegistryInitializedIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryInitializedIterator
}

// FilterInitialized multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterInitialized(opts *bind.FilterOpts) (retVal *FilterInitializedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterInitializedOutput{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterInitialized(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry013Result = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterInitialized(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry014Result = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterInitialized not implemented (tag=%s)", merged.currTag)
	return
}

// WatchInitialized multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryInitialized, sinkAlt6 chan<- *scannerregistry014.ScannerRegistryInitialized) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchInitialized(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchInitialized(opts, sinkAlt6)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchInitialized not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerRegistryInitialized is a merged return type.
type ScannerRegistryInitialized struct {
	Version uint8

	Raw types.Log
}

// ParseInitialized multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseInitialized(log types.Log) (retVal *ScannerRegistryInitialized, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ScannerRegistryInitialized{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseInitialized(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Version = val.Version

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseInitialized(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Version = val.Version

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseInitialized not implemented (tag=%s)", merged.currTag)
	return
}

// FilterManagerEnabledOutput is a merged return type.
type FilterManagerEnabledOutput struct {
	Scannerregistry013Result *scannerregistry013.ScannerRegistryManagerEnabledIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryManagerEnabledIterator
}

// FilterManagerEnabled multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterManagerEnabled(opts *bind.FilterOpts, scannerId []*big.Int, manager []common.Address) (retVal *FilterManagerEnabledOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterManagerEnabledOutput{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterManagerEnabled(opts, scannerId, manager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry013Result = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterManagerEnabled(opts, scannerId, manager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry014Result = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterManagerEnabled not implemented (tag=%s)", merged.currTag)
	return
}

// WatchManagerEnabled multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchManagerEnabled(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryManagerEnabled, scannerId []*big.Int, manager []common.Address, sinkAlt7 chan<- *scannerregistry014.ScannerRegistryManagerEnabled) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchManagerEnabled(opts, sink, scannerId, manager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchManagerEnabled(opts, sinkAlt7, scannerId, manager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchManagerEnabled not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerRegistryManagerEnabled is a merged return type.
type ScannerRegistryManagerEnabled struct {
	ScannerId *big.Int

	Manager common.Address

	Enabled bool

	Raw types.Log
}

// ParseManagerEnabled multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseManagerEnabled(log types.Log) (retVal *ScannerRegistryManagerEnabled, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ScannerRegistryManagerEnabled{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseManagerEnabled(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.ScannerId = val.ScannerId

		retVal.Manager = val.Manager

		retVal.Enabled = val.Enabled

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseManagerEnabled(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.ScannerId = val.ScannerId

		retVal.Manager = val.Manager

		retVal.Enabled = val.Enabled

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseManagerEnabled not implemented (tag=%s)", merged.currTag)
	return
}

// FilterRouterUpdatedOutput is a merged return type.
type FilterRouterUpdatedOutput struct {
	Scannerregistry013Result *scannerregistry013.ScannerRegistryRouterUpdatedIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryRouterUpdatedIterator
}

// FilterRouterUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterRouterUpdated(opts *bind.FilterOpts, router []common.Address) (retVal *FilterRouterUpdatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterRouterUpdatedOutput{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterRouterUpdated(opts, router)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry013Result = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterRouterUpdated(opts, router)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry014Result = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// WatchRouterUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchRouterUpdated(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryRouterUpdated, router []common.Address, sinkAlt8 chan<- *scannerregistry014.ScannerRegistryRouterUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchRouterUpdated(opts, sink, router)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchRouterUpdated(opts, sinkAlt8, router)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerRegistryRouterUpdated is a merged return type.
type ScannerRegistryRouterUpdated struct {
	Router common.Address

	Raw types.Log
}

// ParseRouterUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseRouterUpdated(log types.Log) (retVal *ScannerRegistryRouterUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ScannerRegistryRouterUpdated{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseRouterUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Router = val.Router

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseRouterUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Router = val.Router

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// FilterScannerEnabledOutput is a merged return type.
type FilterScannerEnabledOutput struct {
	Scannerregistry013Result *scannerregistry013.ScannerRegistryScannerEnabledIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryScannerEnabledIterator
}

// FilterScannerEnabled multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterScannerEnabled(opts *bind.FilterOpts, scannerId []*big.Int, enabled []bool) (retVal *FilterScannerEnabledOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterScannerEnabledOutput{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterScannerEnabled(opts, scannerId, enabled)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry013Result = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterScannerEnabled(opts, scannerId, enabled)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry014Result = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterScannerEnabled not implemented (tag=%s)", merged.currTag)
	return
}

// WatchScannerEnabled multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchScannerEnabled(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryScannerEnabled, scannerId []*big.Int, enabled []bool, sinkAlt9 chan<- *scannerregistry014.ScannerRegistryScannerEnabled) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchScannerEnabled(opts, sink, scannerId, enabled)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchScannerEnabled(opts, sinkAlt9, scannerId, enabled)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchScannerEnabled not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerRegistryScannerEnabled is a merged return type.
type ScannerRegistryScannerEnabled struct {
	ScannerId *big.Int

	Enabled bool

	Permission uint8

	Value bool

	Raw types.Log
}

// ParseScannerEnabled multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseScannerEnabled(log types.Log) (retVal *ScannerRegistryScannerEnabled, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ScannerRegistryScannerEnabled{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseScannerEnabled(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.ScannerId = val.ScannerId

		retVal.Enabled = val.Enabled

		retVal.Permission = val.Permission

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseScannerEnabled(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.ScannerId = val.ScannerId

		retVal.Enabled = val.Enabled

		retVal.Permission = val.Permission

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseScannerEnabled not implemented (tag=%s)", merged.currTag)
	return
}

// FilterScannerUpdatedOutput is a merged return type.
type FilterScannerUpdatedOutput struct {
	Scannerregistry013Result *scannerregistry013.ScannerRegistryScannerUpdatedIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryScannerUpdatedIterator
}

// FilterScannerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterScannerUpdated(opts *bind.FilterOpts, scannerId []*big.Int, chainId []*big.Int) (retVal *FilterScannerUpdatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterScannerUpdatedOutput{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterScannerUpdated(opts, scannerId, chainId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry013Result = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterScannerUpdated(opts, scannerId, chainId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry014Result = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterScannerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// WatchScannerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchScannerUpdated(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryScannerUpdated, scannerId []*big.Int, chainId []*big.Int, sinkAlt10 chan<- *scannerregistry014.ScannerRegistryScannerUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchScannerUpdated(opts, sink, scannerId, chainId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchScannerUpdated(opts, sinkAlt10, scannerId, chainId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchScannerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerRegistryScannerUpdated is a merged return type.
type ScannerRegistryScannerUpdated struct {
	ScannerId *big.Int

	ChainId *big.Int

	Metadata string

	Raw types.Log
}

// ParseScannerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseScannerUpdated(log types.Log) (retVal *ScannerRegistryScannerUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ScannerRegistryScannerUpdated{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseScannerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.ScannerId = val.ScannerId

		retVal.ChainId = val.ChainId

		retVal.Metadata = val.Metadata

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseScannerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.ScannerId = val.ScannerId

		retVal.ChainId = val.ChainId

		retVal.Metadata = val.Metadata

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseScannerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// FilterStakeControllerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterStakeControllerUpdated(opts *bind.FilterOpts, newstakeController []common.Address) (retVal *scannerregistry013.ScannerRegistryStakeControllerUpdatedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterStakeControllerUpdated(opts, newstakeController)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterStakeControllerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// WatchStakeControllerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchStakeControllerUpdated(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryStakeControllerUpdated, newstakeController []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchStakeControllerUpdated(opts, sink, newstakeController)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchStakeControllerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerRegistryStakeControllerUpdated is a merged return type.
type ScannerRegistryStakeControllerUpdated struct {
	NewstakeController common.Address

	Raw types.Log
}

// ParseStakeControllerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseStakeControllerUpdated(log types.Log) (retVal *ScannerRegistryStakeControllerUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ScannerRegistryStakeControllerUpdated{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseStakeControllerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewstakeController = val.NewstakeController

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseStakeControllerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// FilterStakeThresholdChangedOutput is a merged return type.
type FilterStakeThresholdChangedOutput struct {
	Scannerregistry013Result *scannerregistry013.ScannerRegistryStakeThresholdChangedIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryStakeThresholdChangedIterator
}

// FilterStakeThresholdChanged multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterStakeThresholdChanged(opts *bind.FilterOpts, chainId []*big.Int) (retVal *FilterStakeThresholdChangedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterStakeThresholdChangedOutput{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterStakeThresholdChanged(opts, chainId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry013Result = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterStakeThresholdChanged(opts, chainId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry014Result = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterStakeThresholdChanged not implemented (tag=%s)", merged.currTag)
	return
}

// WatchStakeThresholdChanged multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchStakeThresholdChanged(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryStakeThresholdChanged, chainId []*big.Int, sinkAlt11 chan<- *scannerregistry014.ScannerRegistryStakeThresholdChanged) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchStakeThresholdChanged(opts, sink, chainId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchStakeThresholdChanged(opts, sinkAlt11, chainId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchStakeThresholdChanged not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerRegistryStakeThresholdChanged is a merged return type.
type ScannerRegistryStakeThresholdChanged struct {
	ChainId *big.Int

	Min *big.Int

	Max *big.Int

	Activated bool

	Raw types.Log
}

// ParseStakeThresholdChanged multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseStakeThresholdChanged(log types.Log) (retVal *ScannerRegistryStakeThresholdChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ScannerRegistryStakeThresholdChanged{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseStakeThresholdChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.ChainId = val.ChainId

		retVal.Min = val.Min

		retVal.Max = val.Max

		retVal.Activated = val.Activated

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseStakeThresholdChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.ChainId = val.ChainId

		retVal.Min = val.Min

		retVal.Max = val.Max

		retVal.Activated = val.Activated

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseStakeThresholdChanged not implemented (tag=%s)", merged.currTag)
	return
}

// FilterTransferOutput is a merged return type.
type FilterTransferOutput struct {
	Scannerregistry013Result *scannerregistry013.ScannerRegistryTransferIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryTransferIterator
}

// FilterTransfer multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (retVal *FilterTransferOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterTransferOutput{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterTransfer(opts, from, to, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry013Result = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterTransfer(opts, from, to, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry014Result = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterTransfer not implemented (tag=%s)", merged.currTag)
	return
}

// WatchTransfer multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryTransfer, from []common.Address, to []common.Address, tokenId []*big.Int, sinkAlt12 chan<- *scannerregistry014.ScannerRegistryTransfer) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchTransfer(opts, sink, from, to, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchTransfer(opts, sinkAlt12, from, to, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchTransfer not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerRegistryTransfer is a merged return type.
type ScannerRegistryTransfer struct {
	From common.Address

	To common.Address

	TokenId *big.Int

	Raw types.Log
}

// ParseTransfer multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseTransfer(log types.Log) (retVal *ScannerRegistryTransfer, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ScannerRegistryTransfer{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseTransfer(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.From = val.From

		retVal.To = val.To

		retVal.TokenId = val.TokenId

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseTransfer(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.From = val.From

		retVal.To = val.To

		retVal.TokenId = val.TokenId

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseTransfer not implemented (tag=%s)", merged.currTag)
	return
}

// FilterUpgradedOutput is a merged return type.
type FilterUpgradedOutput struct {
	Scannerregistry013Result *scannerregistry013.ScannerRegistryUpgradedIterator

	Scannerregistry014Result *scannerregistry014.ScannerRegistryUpgradedIterator
}

// FilterUpgraded multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterUpgraded(opts *bind.FilterOpts, implementation []common.Address) (retVal *FilterUpgradedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterUpgradedOutput{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.FilterUpgraded(opts, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry013Result = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterUpgraded(opts, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Scannerregistry014Result = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// WatchUpgraded multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchUpgraded(opts *bind.WatchOpts, sink chan<- *scannerregistry013.ScannerRegistryUpgraded, implementation []common.Address, sinkAlt13 chan<- *scannerregistry014.ScannerRegistryUpgraded) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.WatchUpgraded(opts, sink, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchUpgraded(opts, sinkAlt13, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerRegistryUpgraded is a merged return type.
type ScannerRegistryUpgraded struct {
	Implementation common.Address

	Raw types.Log
}

// ParseUpgraded multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseUpgraded(log types.Log) (retVal *ScannerRegistryUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ScannerRegistryUpgraded{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ParseUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// FilterConfiguredMigration multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterConfiguredMigration(opts *bind.FilterOpts) (retVal *scannerregistry014.ScannerRegistryConfiguredMigrationIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterConfiguredMigration(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterConfiguredMigration not implemented (tag=%s)", merged.currTag)
	return
}

// WatchConfiguredMigration multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchConfiguredMigration(opts *bind.WatchOpts, sink chan<- *scannerregistry014.ScannerRegistryConfiguredMigration) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchConfiguredMigration(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchConfiguredMigration not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerRegistryConfiguredMigration is a merged return type.
type ScannerRegistryConfiguredMigration struct {
	SunsettingTime *big.Int

	ScannerPoolRegistry common.Address

	Raw types.Log
}

// ParseConfiguredMigration multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseConfiguredMigration(log types.Log) (retVal *ScannerRegistryConfiguredMigration, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ScannerRegistryConfiguredMigration{}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseConfiguredMigration(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SunsettingTime = val.SunsettingTime

		retVal.ScannerPoolRegistry = val.ScannerPoolRegistry

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseConfiguredMigration not implemented (tag=%s)", merged.currTag)
	return
}

// FilterDeregisteredScanner multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterDeregisteredScanner(opts *bind.FilterOpts) (retVal *scannerregistry014.ScannerRegistryDeregisteredScannerIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterDeregisteredScanner(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterDeregisteredScanner not implemented (tag=%s)", merged.currTag)
	return
}

// WatchDeregisteredScanner multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchDeregisteredScanner(opts *bind.WatchOpts, sink chan<- *scannerregistry014.ScannerRegistryDeregisteredScanner) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchDeregisteredScanner(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchDeregisteredScanner not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerRegistryDeregisteredScanner is a merged return type.
type ScannerRegistryDeregisteredScanner struct {
	ScannerId *big.Int

	Raw types.Log
}

// ParseDeregisteredScanner multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseDeregisteredScanner(log types.Log) (retVal *ScannerRegistryDeregisteredScanner, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ScannerRegistryDeregisteredScanner{}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseDeregisteredScanner(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.ScannerId = val.ScannerId

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseDeregisteredScanner not implemented (tag=%s)", merged.currTag)
	return
}

// FilterSubjectHandlerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) FilterSubjectHandlerUpdated(opts *bind.FilterOpts, newHandler []common.Address) (retVal *scannerregistry014.ScannerRegistrySubjectHandlerUpdatedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.FilterSubjectHandlerUpdated(opts, newHandler)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.FilterSubjectHandlerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// WatchSubjectHandlerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) WatchSubjectHandlerUpdated(opts *bind.WatchOpts, sink chan<- *scannerregistry014.ScannerRegistrySubjectHandlerUpdated, newHandler []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.WatchSubjectHandlerUpdated(opts, sink, newHandler)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.WatchSubjectHandlerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerRegistrySubjectHandlerUpdated is a merged return type.
type ScannerRegistrySubjectHandlerUpdated struct {
	NewHandler common.Address

	Raw types.Log
}

// ParseSubjectHandlerUpdated multiplexes to different implementations of the method.
func (merged *ScannerRegistryFilterer) ParseSubjectHandlerUpdated(log types.Log) (retVal *ScannerRegistrySubjectHandlerUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &ScannerRegistrySubjectHandlerUpdated{}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ParseSubjectHandlerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewHandler = val.NewHandler

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("ScannerRegistryFilterer.ParseSubjectHandlerUpdated not implemented (tag=%s)", merged.currTag)
	return
}
