// Code generated by go-merge-types. DO NOT EDIT.

package contract_scanner_registry

import (
	import_fmt "fmt"
	import_sync "sync"


	scannerregistry013 "github.com/forta-network/forta-core-go/contracts/generated/contract_scanner_registry_0_1_3"

	scannerregistry014 "github.com/forta-network/forta-core-go/contracts/generated/contract_scanner_registry_0_1_4"



	"github.com/ethereum/go-ethereum/accounts/abi/bind"

	"github.com/ethereum/go-ethereum/common"

	"math/big"

)

// ScannerRegistryCaller is a new type which can multiplex calls to different implementation types.
type ScannerRegistryCaller struct {

	typ0 *scannerregistry013.ScannerRegistryCaller

	typ1 *scannerregistry014.ScannerRegistryCaller

	currTag string
	mu import_sync.RWMutex
	unsafe bool // default: false
}

// NewScannerRegistryCaller creates a new merged type.
func NewScannerRegistryCaller(address common.Address, caller bind.ContractCaller) (*ScannerRegistryCaller, error) {
	var (
		mergedType ScannerRegistryCaller
		err error
	)
	mergedType.currTag = "0.1.4"


	mergedType.typ0, err = scannerregistry013.NewScannerRegistryCaller(address, caller)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize scannerregistry013.ScannerRegistryCaller: %v", err)
	}

	mergedType.typ1, err = scannerregistry014.NewScannerRegistryCaller(address, caller)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize scannerregistry014.ScannerRegistryCaller: %v", err)
	}


	return &mergedType, nil
}

// IsKnownTagForScannerRegistryCaller tells if given tag is a known tag.
func IsKnownTagForScannerRegistryCaller(tag string) bool {

	if tag == "0.1.3" {
		return true
	}

	if tag == "0.1.4" {
		return true
	}

	return false
}

// Use sets the used implementation to given tag.
func (merged *ScannerRegistryCaller) Use(tag string) (changed bool) {
	if !merged.unsafe {
		merged.mu.Lock()
		defer merged.mu.Unlock()
	}
	// use the default tag if the provided tag is unknown
	if !IsKnownTagForScannerRegistryCaller(tag) {
		tag = "0.1.4"
	}
	changed = merged.currTag != tag
	merged.currTag = tag
	return
}

// Unsafe disables the mutex.
func (merged *ScannerRegistryCaller) Unsafe() {
	merged.unsafe = true
}

// Safe enables the mutex.
func (merged *ScannerRegistryCaller) Safe() {
	merged.unsafe = false
}




// BalanceOf multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) BalanceOf(opts *bind.CallOpts, owner common.Address) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.BalanceOf(opts, owner)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.BalanceOf(opts, owner)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.BalanceOf not implemented (tag=%s)", merged.currTag)
	return
}



// GetApproved multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.GetApproved(opts, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.GetApproved(opts, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.GetApproved not implemented (tag=%s)", merged.currTag)
	return
}



// GetDisableFlags multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetDisableFlags(opts *bind.CallOpts, scannerId *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.GetDisableFlags(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.GetDisableFlags not implemented (tag=%s)", merged.currTag)
	return
}



// GetManagerAt multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetManagerAt(opts *bind.CallOpts, scannerId *big.Int, index *big.Int) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.GetManagerAt(opts, scannerId, index)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.GetManagerAt(opts, scannerId, index)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.GetManagerAt not implemented (tag=%s)", merged.currTag)
	return
}



// GetManagerCount multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetManagerCount(opts *bind.CallOpts, scannerId *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.GetManagerCount(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.GetManagerCount(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.GetManagerCount not implemented (tag=%s)", merged.currTag)
	return
}


// GetScannerOutput is a merged return type.
type GetScannerOutput struct {

	Registered bool

	Owner common.Address

	ChainId *big.Int

	Metadata string

}

// GetScanner multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetScanner(opts *bind.CallOpts, scannerId *big.Int) (retVal *GetScannerOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &GetScannerOutput{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.GetScanner(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Registered = val.Registered

		retVal.Owner = val.Owner

		retVal.ChainId = val.ChainId

		retVal.Metadata = val.Metadata


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.GetScanner(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Registered = val.Registered

		retVal.Owner = val.Owner

		retVal.ChainId = val.ChainId

		retVal.Metadata = val.Metadata


		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.GetScanner not implemented (tag=%s)", merged.currTag)
	return
}



// GetScannerChainId multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetScannerChainId(opts *bind.CallOpts, scannerId *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.GetScannerChainId(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.GetScannerChainId(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.GetScannerChainId not implemented (tag=%s)", merged.currTag)
	return
}


// GetScannerStateOutput is a merged return type.
type GetScannerStateOutput struct {

	Registered bool

	Owner common.Address

	ChainId *big.Int

	Metadata string

	Enabled bool

	DisabledFlags *big.Int

}

// GetScannerState multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetScannerState(opts *bind.CallOpts, scannerId *big.Int) (retVal *GetScannerStateOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &GetScannerStateOutput{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.GetScannerState(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Registered = val.Registered

		retVal.Owner = val.Owner

		retVal.ChainId = val.ChainId

		retVal.Metadata = val.Metadata

		retVal.Enabled = val.Enabled

		retVal.DisabledFlags = val.DisabledFlags


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.GetScannerState(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Registered = val.Registered

		retVal.Owner = val.Owner

		retVal.ChainId = val.ChainId

		retVal.Metadata = val.Metadata

		retVal.Enabled = val.Enabled

		retVal.DisabledFlags = val.DisabledFlags


		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.GetScannerState not implemented (tag=%s)", merged.currTag)
	return
}



// GetStakeController multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetStakeController(opts *bind.CallOpts) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.GetStakeController(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.GetStakeController not implemented (tag=%s)", merged.currTag)
	return
}


// GetStakeThresholdOutput is a merged return type.
type GetStakeThresholdOutput struct {

	Min *big.Int

	Max *big.Int

	Activated bool

}

// GetStakeThreshold multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetStakeThreshold(opts *bind.CallOpts, subject *big.Int) (retVal *GetStakeThresholdOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &GetStakeThresholdOutput{}



	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.GetStakeThreshold(opts, subject)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Min = val.Min

		retVal.Max = val.Max

		retVal.Activated = val.Activated


		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.GetStakeThreshold(opts, subject)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Min = val.Min

		retVal.Max = val.Max

		retVal.Activated = val.Activated


		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.GetStakeThreshold not implemented (tag=%s)", merged.currTag)
	return
}



// IsApprovedForAll multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.IsApprovedForAll(opts, owner, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.IsApprovedForAll(opts, owner, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.IsApprovedForAll not implemented (tag=%s)", merged.currTag)
	return
}



// IsEnabled multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) IsEnabled(opts *bind.CallOpts, scannerId *big.Int) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.IsEnabled(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.IsEnabled(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.IsEnabled not implemented (tag=%s)", merged.currTag)
	return
}



// IsManager multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) IsManager(opts *bind.CallOpts, scannerId *big.Int, manager common.Address) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.IsManager(opts, scannerId, manager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.IsManager(opts, scannerId, manager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.IsManager not implemented (tag=%s)", merged.currTag)
	return
}



// IsRegistered multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) IsRegistered(opts *bind.CallOpts, scannerId *big.Int) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.IsRegistered(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.IsRegistered(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.IsRegistered not implemented (tag=%s)", merged.currTag)
	return
}



// IsStakedOverMin multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) IsStakedOverMin(opts *bind.CallOpts, subject *big.Int) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.IsStakedOverMin(opts, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.IsStakedOverMin(opts, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.IsStakedOverMin not implemented (tag=%s)", merged.currTag)
	return
}



// IsTrustedForwarder multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) IsTrustedForwarder(opts *bind.CallOpts, forwarder common.Address) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.IsTrustedForwarder(opts, forwarder)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.IsTrustedForwarder not implemented (tag=%s)", merged.currTag)
	return
}



// Name multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) Name(opts *bind.CallOpts) (retVal string, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.Name(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.Name(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.Name not implemented (tag=%s)", merged.currTag)
	return
}



// OwnerOf multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) OwnerOf(opts *bind.CallOpts, tokenId *big.Int, subject *big.Int) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.OwnerOf(opts, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.OwnerOf(opts, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.OwnerOf not implemented (tag=%s)", merged.currTag)
	return
}



// ProxiableUUID multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) ProxiableUUID(opts *bind.CallOpts) (retVal [32]byte, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ProxiableUUID(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ProxiableUUID(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.ProxiableUUID not implemented (tag=%s)", merged.currTag)
	return
}



// ScannerAddressToId multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) ScannerAddressToId(opts *bind.CallOpts, scanner common.Address) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ScannerAddressToId(opts, scanner)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ScannerAddressToId(opts, scanner)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.ScannerAddressToId not implemented (tag=%s)", merged.currTag)
	return
}



// SupportsInterface multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.SupportsInterface(opts, interfaceId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.SupportsInterface(opts, interfaceId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.SupportsInterface not implemented (tag=%s)", merged.currTag)
	return
}



// Symbol multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) Symbol(opts *bind.CallOpts) (retVal string, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.Symbol(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.Symbol(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.Symbol not implemented (tag=%s)", merged.currTag)
	return
}



// TokenURI multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) TokenURI(opts *bind.CallOpts, tokenId *big.Int) (retVal string, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.TokenURI(opts, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.TokenURI(opts, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.TokenURI not implemented (tag=%s)", merged.currTag)
	return
}



// Version multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) Version(opts *bind.CallOpts) (retVal string, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.Version(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.Version(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.Version not implemented (tag=%s)", merged.currTag)
	return
}



// GetSubjectHandler multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetSubjectHandler(opts *bind.CallOpts) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.GetSubjectHandler(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.GetSubjectHandler not implemented (tag=%s)", merged.currTag)
	return
}



// HasMigrationEnded multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) HasMigrationEnded(opts *bind.CallOpts) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.HasMigrationEnded(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.HasMigrationEnded not implemented (tag=%s)", merged.currTag)
	return
}



// OptingOutOfMigration multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) OptingOutOfMigration(opts *bind.CallOpts, arg0 *big.Int) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.OptingOutOfMigration(opts, arg0)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.OptingOutOfMigration not implemented (tag=%s)", merged.currTag)
	return
}



// ScannerPoolRegistry multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) ScannerPoolRegistry(opts *bind.CallOpts) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ScannerPoolRegistry(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.ScannerPoolRegistry not implemented (tag=%s)", merged.currTag)
	return
}



// SunsettingTime multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) SunsettingTime(opts *bind.CallOpts) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.SunsettingTime(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("ScannerRegistryCaller.SunsettingTime not implemented (tag=%s)", merged.currTag)
	return
}