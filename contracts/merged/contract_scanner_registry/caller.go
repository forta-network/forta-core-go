// Code generated by go-merge-types. DO NOT EDIT.

package contract_scanner_registry

import (
	import_fmt "fmt"
	import_sync "sync"

	scannerregistry013 "github.com/forta-network/forta-core-go/contracts/generated/contract_scanner_registry_0_1_3"

	scannerregistry014 "github.com/forta-network/forta-core-go/contracts/generated/contract_scanner_registry_0_1_4"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"

	"github.com/ethereum/go-ethereum/common"

	"math/big"
)

// ScannerRegistryCaller is a new type which can multiplex calls to different implementation types.
type ScannerRegistryCaller struct {
	typ0 *scannerregistry013.ScannerRegistryCaller

	typ1 *scannerregistry014.ScannerRegistryCaller

	currTag string
	mu      import_sync.RWMutex
	unsafe  bool // default: false
}

// NewScannerRegistryCaller creates a new merged type.
func NewScannerRegistryCaller(address common.Address, caller bind.ContractCaller) (*ScannerRegistryCaller, error) {
	var (
		mergedType ScannerRegistryCaller
		err        error
	)
	mergedType.currTag = "0.1.3"

	mergedType.typ0, err = scannerregistry013.NewScannerRegistryCaller(address, caller)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize scannerregistry013.ScannerRegistryCaller: %v", err)
	}

	mergedType.typ1, err = scannerregistry014.NewScannerRegistryCaller(address, caller)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize scannerregistry014.ScannerRegistryCaller: %v", err)
	}

	return &mergedType, nil
}

// IsKnownTagForScannerRegistryCaller tells if given tag is a known tag.
func IsKnownTagForScannerRegistryCaller(tag string) bool {

	if tag == "0.1.3" {
		return true
	}

	if tag == "0.1.4" {
		return true
	}

	return false
}

// Use sets the used implementation to given tag.
func (merged *ScannerRegistryCaller) Use(tag string) (changed bool) {
	if !merged.unsafe {
		merged.mu.Lock()
		defer merged.mu.Unlock()
	}
	// use the default tag if the provided tag is unknown
	if !IsKnownTagForScannerRegistryCaller(tag) {
		tag = "0.1.3"
	}
	changed = merged.currTag != tag
	merged.currTag = tag
	return
}

// Unsafe disables the mutex.
func (merged *ScannerRegistryCaller) Unsafe() {
	merged.unsafe = true
}

// Safe enables the mutex.
func (merged *ScannerRegistryCaller) Safe() {
	merged.unsafe = false
}

// BalanceOf multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) BalanceOf(opts *bind.CallOpts, owner common.Address) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.BalanceOf(opts, owner)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.BalanceOf(opts, owner)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.BalanceOf not implemented (tag=%s)", merged.currTag)
	return
}

// GetApproved multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.GetApproved(opts, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.GetApproved(opts, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.GetApproved not implemented (tag=%s)", merged.currTag)
	return
}

// GetDisableFlags multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetDisableFlags(opts *bind.CallOpts, scannerId *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.GetDisableFlags(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.GetDisableFlags not implemented (tag=%s)", merged.currTag)
	return
}

// GetManagerAt multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetManagerAt(opts *bind.CallOpts, scannerId *big.Int, index *big.Int) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.GetManagerAt(opts, scannerId, index)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.GetManagerAt(opts, scannerId, index)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.GetManagerAt not implemented (tag=%s)", merged.currTag)
	return
}

// GetManagerCount multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetManagerCount(opts *bind.CallOpts, scannerId *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.GetManagerCount(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.GetManagerCount(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.GetManagerCount not implemented (tag=%s)", merged.currTag)
	return
}

// GetScannerOutput is a merged return type.
type GetScannerOutput struct {
	Registered bool

	Owner common.Address

	ChainId *big.Int

	Metadata string
}

// GetScanner multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetScanner(opts *bind.CallOpts, scannerId *big.Int) (retVal *GetScannerOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &GetScannerOutput{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.GetScanner(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Registered = val.Registered

		retVal.Owner = val.Owner

		retVal.ChainId = val.ChainId

		retVal.Metadata = val.Metadata

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.GetScanner(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Registered = val.Registered

		retVal.Owner = val.Owner

		retVal.ChainId = val.ChainId

		retVal.Metadata = val.Metadata

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.GetScanner not implemented (tag=%s)", merged.currTag)
	return
}

// GetScannerChainId multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetScannerChainId(opts *bind.CallOpts, scannerId *big.Int) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.GetScannerChainId(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.GetScannerChainId(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.GetScannerChainId not implemented (tag=%s)", merged.currTag)
	return
}

// GetScannerStateOutput is a merged return type.
type GetScannerStateOutput struct {
	Registered bool

	Owner common.Address

	ChainId *big.Int

	Metadata string

	Enabled bool

	DisabledFlags *big.Int
}

// GetScannerState multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetScannerState(opts *bind.CallOpts, scannerId *big.Int) (retVal *GetScannerStateOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &GetScannerStateOutput{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.GetScannerState(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Registered = val.Registered

		retVal.Owner = val.Owner

		retVal.ChainId = val.ChainId

		retVal.Metadata = val.Metadata

		retVal.Enabled = val.Enabled

		retVal.DisabledFlags = val.DisabledFlags

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.GetScannerState(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Registered = val.Registered

		retVal.Owner = val.Owner

		retVal.ChainId = val.ChainId

		retVal.Metadata = val.Metadata

		retVal.Enabled = val.Enabled

		retVal.DisabledFlags = val.DisabledFlags

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.GetScannerState not implemented (tag=%s)", merged.currTag)
	return
}

// GetStakeController multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetStakeController(opts *bind.CallOpts) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.GetStakeController(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.GetStakeController not implemented (tag=%s)", merged.currTag)
	return
}

// GetStakeThresholdOutput is a merged return type.
type GetStakeThresholdOutput struct {
	Min *big.Int

	Max *big.Int

	Activated bool
}

// GetStakeThreshold multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetStakeThreshold(opts *bind.CallOpts, subject *big.Int) (retVal *GetStakeThresholdOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &GetStakeThresholdOutput{}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.GetStakeThreshold(opts, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Min = val.Min

		retVal.Max = val.Max

		retVal.Activated = val.Activated

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.GetStakeThreshold(opts, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Min = val.Min

		retVal.Max = val.Max

		retVal.Activated = val.Activated

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.GetStakeThreshold not implemented (tag=%s)", merged.currTag)
	return
}

// IsApprovedForAll multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.IsApprovedForAll(opts, owner, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.IsApprovedForAll(opts, owner, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.IsApprovedForAll not implemented (tag=%s)", merged.currTag)
	return
}

// IsEnabled multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) IsEnabled(opts *bind.CallOpts, scannerId *big.Int) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.IsEnabled(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.IsEnabled(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.IsEnabled not implemented (tag=%s)", merged.currTag)
	return
}

// IsManager multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) IsManager(opts *bind.CallOpts, scannerId *big.Int, manager common.Address) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.IsManager(opts, scannerId, manager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.IsManager(opts, scannerId, manager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.IsManager not implemented (tag=%s)", merged.currTag)
	return
}

// IsRegistered multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) IsRegistered(opts *bind.CallOpts, scannerId *big.Int) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.IsRegistered(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.IsRegistered(opts, scannerId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.IsRegistered not implemented (tag=%s)", merged.currTag)
	return
}

// IsStakedOverMin multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) IsStakedOverMin(opts *bind.CallOpts, subject *big.Int) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.IsStakedOverMin(opts, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.IsStakedOverMin(opts, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.IsStakedOverMin not implemented (tag=%s)", merged.currTag)
	return
}

// IsTrustedForwarder multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) IsTrustedForwarder(opts *bind.CallOpts, forwarder common.Address) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.IsTrustedForwarder(opts, forwarder)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.IsTrustedForwarder(opts, forwarder)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.IsTrustedForwarder not implemented (tag=%s)", merged.currTag)
	return
}

// Name multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) Name(opts *bind.CallOpts) (retVal string, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.Name(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.Name(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.Name not implemented (tag=%s)", merged.currTag)
	return
}

// OwnerOf multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) OwnerOf(opts *bind.CallOpts, tokenId *big.Int, subject *big.Int) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.OwnerOf(opts, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.OwnerOf(opts, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.OwnerOf not implemented (tag=%s)", merged.currTag)
	return
}

// ProxiableUUID multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) ProxiableUUID(opts *bind.CallOpts) (retVal [32]byte, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ProxiableUUID(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ProxiableUUID(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.ProxiableUUID not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerAddressToId multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) ScannerAddressToId(opts *bind.CallOpts, scanner common.Address) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.ScannerAddressToId(opts, scanner)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ScannerAddressToId(opts, scanner)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.ScannerAddressToId not implemented (tag=%s)", merged.currTag)
	return
}

// SupportsInterface multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.SupportsInterface(opts, interfaceId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.SupportsInterface(opts, interfaceId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.SupportsInterface not implemented (tag=%s)", merged.currTag)
	return
}

// Symbol multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) Symbol(opts *bind.CallOpts) (retVal string, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.Symbol(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.Symbol(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.Symbol not implemented (tag=%s)", merged.currTag)
	return
}

// TokenURI multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) TokenURI(opts *bind.CallOpts, tokenId *big.Int) (retVal string, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.TokenURI(opts, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.TokenURI(opts, tokenId)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.TokenURI not implemented (tag=%s)", merged.currTag)
	return
}

// Version multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) Version(opts *bind.CallOpts) (retVal string, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.3" {
		val, methodErr := merged.typ0.Version(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.Version(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.Version not implemented (tag=%s)", merged.currTag)
	return
}

// GetSubjectHandler multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) GetSubjectHandler(opts *bind.CallOpts) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.GetSubjectHandler(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.GetSubjectHandler not implemented (tag=%s)", merged.currTag)
	return
}

// HasMigrationEnded multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) HasMigrationEnded(opts *bind.CallOpts) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.HasMigrationEnded(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.HasMigrationEnded not implemented (tag=%s)", merged.currTag)
	return
}

// OptingOutOfMigration multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) OptingOutOfMigration(opts *bind.CallOpts, arg0 *big.Int) (retVal bool, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.OptingOutOfMigration(opts, arg0)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.OptingOutOfMigration not implemented (tag=%s)", merged.currTag)
	return
}

// ScannerPoolRegistry multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) ScannerPoolRegistry(opts *bind.CallOpts) (retVal common.Address, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.ScannerPoolRegistry(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.ScannerPoolRegistry not implemented (tag=%s)", merged.currTag)
	return
}

// SunsettingTime multiplexes to different implementations of the method.
func (merged *ScannerRegistryCaller) SunsettingTime(opts *bind.CallOpts) (retVal *big.Int, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.4" {
		val, methodErr := merged.typ1.SunsettingTime(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("ScannerRegistryCaller.SunsettingTime not implemented (tag=%s)", merged.currTag)
	return
}
