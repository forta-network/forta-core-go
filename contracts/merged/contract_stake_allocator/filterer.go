// Code generated by go-merge-types. DO NOT EDIT.

package contract_stake_allocator

import (
	import_fmt "fmt"
	import_sync "sync"


	stakeallocator010 "github.com/forta-network/forta-core-go/contracts/generated/contract_stake_allocator_0_1_0"



	"github.com/ethereum/go-ethereum/accounts/abi/bind"

	"github.com/ethereum/go-ethereum/event"

	"github.com/ethereum/go-ethereum/core/types"

	"github.com/ethereum/go-ethereum/common"

	"math/big"

)

// StakeAllocatorFilterer is a new type which can multiplex calls to different implementation types.
type StakeAllocatorFilterer struct {

	typ0 *stakeallocator010.StakeAllocatorFilterer

	currTag string
	mu import_sync.RWMutex
	unsafe bool // default: false
}

// NewStakeAllocatorFilterer creates a new merged type.
func NewStakeAllocatorFilterer(address common.Address, filterer bind.ContractFilterer) (*StakeAllocatorFilterer, error) {
	var (
		mergedType StakeAllocatorFilterer
		err error
	)
	mergedType.currTag = "0.1.0"


	mergedType.typ0, err = stakeallocator010.NewStakeAllocatorFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize stakeallocator010.StakeAllocatorFilterer: %v", err)
	}


	return &mergedType, nil
}

// IsKnownTag tells if given tag is a known tag.
func IsKnownTag(tag string) bool {

	if tag == "0.1.0" {
		return true
	}

	return false
}

// Use sets the used implementation to given tag.
func (merged *StakeAllocatorFilterer) Use(tag string) (changed bool) {
	if !merged.unsafe {
		merged.mu.Lock()
		defer merged.mu.Unlock()
	}
	// use the default tag if the provided tag is unknown
	if !IsKnownTag(tag) {
		tag = "0.1.0"
	}
	changed = merged.currTag != tag
	merged.currTag = tag
	return
}

// Unsafe disables the mutex.
func (merged *StakeAllocatorFilterer) Unsafe() {
	merged.unsafe = true
}

// Safe enables the mutex.
func (merged *StakeAllocatorFilterer) Safe() {
	merged.unsafe = false
}




// FilterAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) FilterAccessManagerUpdated(opts *bind.FilterOpts, newAddressManager []common.Address) (retVal *stakeallocator010.StakeAllocatorAccessManagerUpdatedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterAccessManagerUpdated(opts, newAddressManager)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.FilterAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) WatchAccessManagerUpdated(opts *bind.WatchOpts, sink chan<- *stakeallocator010.StakeAllocatorAccessManagerUpdated, newAddressManager []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchAccessManagerUpdated(opts, sink, newAddressManager)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.WatchAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// StakeAllocatorAccessManagerUpdated is a merged return type.
type StakeAllocatorAccessManagerUpdated struct {

	NewAddressManager common.Address

	Raw types.Log

}

// ParseAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) ParseAccessManagerUpdated(log types.Log) (retVal *StakeAllocatorAccessManagerUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &StakeAllocatorAccessManagerUpdated{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseAccessManagerUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.NewAddressManager = val.NewAddressManager

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.ParseAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// FilterAdminChanged multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) FilterAdminChanged(opts *bind.FilterOpts) (retVal *stakeallocator010.StakeAllocatorAdminChangedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterAdminChanged(opts)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.FilterAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}



// WatchAdminChanged multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) WatchAdminChanged(opts *bind.WatchOpts, sink chan<- *stakeallocator010.StakeAllocatorAdminChanged) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchAdminChanged(opts, sink)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.WatchAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}


// StakeAllocatorAdminChanged is a merged return type.
type StakeAllocatorAdminChanged struct {

	PreviousAdmin common.Address

	NewAdmin common.Address

	Raw types.Log

}

// ParseAdminChanged multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) ParseAdminChanged(log types.Log) (retVal *StakeAllocatorAdminChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &StakeAllocatorAdminChanged{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseAdminChanged(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.ParseAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}



// FilterAllocatedStake multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) FilterAllocatedStake(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int) (retVal *stakeallocator010.StakeAllocatorAllocatedStakeIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterAllocatedStake(opts, subjectType, subject)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.FilterAllocatedStake not implemented (tag=%s)", merged.currTag)
	return
}



// WatchAllocatedStake multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) WatchAllocatedStake(opts *bind.WatchOpts, sink chan<- *stakeallocator010.StakeAllocatorAllocatedStake, subjectType []uint8, subject []*big.Int) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchAllocatedStake(opts, sink, subjectType, subject)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.WatchAllocatedStake not implemented (tag=%s)", merged.currTag)
	return
}


// StakeAllocatorAllocatedStake is a merged return type.
type StakeAllocatorAllocatedStake struct {

	SubjectType uint8

	Subject *big.Int

	Increase bool

	Amount *big.Int

	TotalAllocated *big.Int

	Raw types.Log

}

// ParseAllocatedStake multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) ParseAllocatedStake(log types.Log) (retVal *StakeAllocatorAllocatedStake, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &StakeAllocatorAllocatedStake{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseAllocatedStake(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Increase = val.Increase

		retVal.Amount = val.Amount

		retVal.TotalAllocated = val.TotalAllocated

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.ParseAllocatedStake not implemented (tag=%s)", merged.currTag)
	return
}



// FilterBeaconUpgraded multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) FilterBeaconUpgraded(opts *bind.FilterOpts, beacon []common.Address) (retVal *stakeallocator010.StakeAllocatorBeaconUpgradedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterBeaconUpgraded(opts, beacon)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.FilterBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// WatchBeaconUpgraded multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) WatchBeaconUpgraded(opts *bind.WatchOpts, sink chan<- *stakeallocator010.StakeAllocatorBeaconUpgraded, beacon []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchBeaconUpgraded(opts, sink, beacon)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.WatchBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// StakeAllocatorBeaconUpgraded is a merged return type.
type StakeAllocatorBeaconUpgraded struct {

	Beacon common.Address

	Raw types.Log

}

// ParseBeaconUpgraded multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) ParseBeaconUpgraded(log types.Log) (retVal *StakeAllocatorBeaconUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &StakeAllocatorBeaconUpgraded{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseBeaconUpgraded(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.ParseBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// FilterInitialized multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) FilterInitialized(opts *bind.FilterOpts) (retVal *stakeallocator010.StakeAllocatorInitializedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterInitialized(opts)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.FilterInitialized not implemented (tag=%s)", merged.currTag)
	return
}



// WatchInitialized multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *stakeallocator010.StakeAllocatorInitialized) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchInitialized(opts, sink)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.WatchInitialized not implemented (tag=%s)", merged.currTag)
	return
}


// StakeAllocatorInitialized is a merged return type.
type StakeAllocatorInitialized struct {

	Version uint8

	Raw types.Log

}

// ParseInitialized multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) ParseInitialized(log types.Log) (retVal *StakeAllocatorInitialized, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &StakeAllocatorInitialized{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseInitialized(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Version = val.Version

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.ParseInitialized not implemented (tag=%s)", merged.currTag)
	return
}



// FilterRouterUpdated multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) FilterRouterUpdated(opts *bind.FilterOpts, router []common.Address) (retVal *stakeallocator010.StakeAllocatorRouterUpdatedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterRouterUpdated(opts, router)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.FilterRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchRouterUpdated multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) WatchRouterUpdated(opts *bind.WatchOpts, sink chan<- *stakeallocator010.StakeAllocatorRouterUpdated, router []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchRouterUpdated(opts, sink, router)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.WatchRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// StakeAllocatorRouterUpdated is a merged return type.
type StakeAllocatorRouterUpdated struct {

	Router common.Address

	Raw types.Log

}

// ParseRouterUpdated multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) ParseRouterUpdated(log types.Log) (retVal *StakeAllocatorRouterUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &StakeAllocatorRouterUpdated{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseRouterUpdated(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Router = val.Router

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.ParseRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// FilterUnallocatedStake multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) FilterUnallocatedStake(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int) (retVal *stakeallocator010.StakeAllocatorUnallocatedStakeIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterUnallocatedStake(opts, subjectType, subject)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.FilterUnallocatedStake not implemented (tag=%s)", merged.currTag)
	return
}



// WatchUnallocatedStake multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) WatchUnallocatedStake(opts *bind.WatchOpts, sink chan<- *stakeallocator010.StakeAllocatorUnallocatedStake, subjectType []uint8, subject []*big.Int) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchUnallocatedStake(opts, sink, subjectType, subject)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.WatchUnallocatedStake not implemented (tag=%s)", merged.currTag)
	return
}


// StakeAllocatorUnallocatedStake is a merged return type.
type StakeAllocatorUnallocatedStake struct {

	SubjectType uint8

	Subject *big.Int

	Increase bool

	Amount *big.Int

	TotalAllocated *big.Int

	Raw types.Log

}

// ParseUnallocatedStake multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) ParseUnallocatedStake(log types.Log) (retVal *StakeAllocatorUnallocatedStake, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &StakeAllocatorUnallocatedStake{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseUnallocatedStake(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Increase = val.Increase

		retVal.Amount = val.Amount

		retVal.TotalAllocated = val.TotalAllocated

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.ParseUnallocatedStake not implemented (tag=%s)", merged.currTag)
	return
}



// FilterUpgraded multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) FilterUpgraded(opts *bind.FilterOpts, implementation []common.Address) (retVal *stakeallocator010.StakeAllocatorUpgradedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterUpgraded(opts, implementation)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.FilterUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// WatchUpgraded multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) WatchUpgraded(opts *bind.WatchOpts, sink chan<- *stakeallocator010.StakeAllocatorUpgraded, implementation []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchUpgraded(opts, sink, implementation)

		if err != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.WatchUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// StakeAllocatorUpgraded is a merged return type.
type StakeAllocatorUpgraded struct {

	Implementation common.Address

	Raw types.Log

}

// ParseUpgraded multiplexes to different implementations of the method.
func (merged *StakeAllocatorFilterer) ParseUpgraded(log types.Log) (retVal *StakeAllocatorUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &StakeAllocatorUpgraded{}



	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseUpgraded(log)

		if err != nil {
			err = methodErr
			return
		}


		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("StakeAllocatorFilterer.ParseUpgraded not implemented (tag=%s)", merged.currTag)
	return
}