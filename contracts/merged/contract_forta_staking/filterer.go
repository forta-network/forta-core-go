// Code generated by go-merge-types. DO NOT EDIT.

package contract_forta_staking

import (
	import_fmt "fmt"
	import_sync "sync"


	fortastaking011 "github.com/forta-network/forta-core-go/contracts/generated/contract_forta_staking_0_1_1"

	fortastaking012 "github.com/forta-network/forta-core-go/contracts/generated/contract_forta_staking_0_1_2"



	"github.com/ethereum/go-ethereum/accounts/abi/bind"

	"github.com/ethereum/go-ethereum/event"

	"github.com/ethereum/go-ethereum/core/types"

	"github.com/ethereum/go-ethereum/common"

	"math/big"

)

// FortaStakingFilterer is a new type which can multiplex calls to different implementation types.
type FortaStakingFilterer struct {

	typ0 *fortastaking011.FortaStakingFilterer

	typ1 *fortastaking012.FortaStakingFilterer

	currTag string
	mu import_sync.RWMutex
	unsafe bool // default: false
}

// NewFortaStakingFilterer creates a new merged type.
func NewFortaStakingFilterer(address common.Address, filterer bind.ContractFilterer) (*FortaStakingFilterer, error) {
	var (
		mergedType FortaStakingFilterer
		err error
	)
	mergedType.currTag = "0.1.2"


	mergedType.typ0, err = fortastaking011.NewFortaStakingFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize fortastaking011.FortaStakingFilterer: %v", err)
	}

	mergedType.typ1, err = fortastaking012.NewFortaStakingFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize fortastaking012.FortaStakingFilterer: %v", err)
	}


	return &mergedType, nil
}

// IsKnownTagForFortaStakingFilterer tells if given tag is a known tag.
func IsKnownTagForFortaStakingFilterer(tag string) bool {

	if tag == "0.1.1" {
		return true
	}

	if tag == "0.1.2" {
		return true
	}

	return false
}

// Use sets the used implementation to given tag.
func (merged *FortaStakingFilterer) Use(tag string) (changed bool) {
	if !merged.unsafe {
		merged.mu.Lock()
		defer merged.mu.Unlock()
	}
	// use the default tag if the provided tag is unknown
	if !IsKnownTagForFortaStakingFilterer(tag) {
		tag = "0.1.2"
	}
	changed = merged.currTag != tag
	merged.currTag = tag
	return
}

// Unsafe disables the mutex.
func (merged *FortaStakingFilterer) Unsafe() {
	merged.unsafe = true
}

// Safe enables the mutex.
func (merged *FortaStakingFilterer) Safe() {
	merged.unsafe = false
}



// FilterAccessManagerUpdatedOutput is a merged return type.
type FilterAccessManagerUpdatedOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingAccessManagerUpdatedIterator

	Fortastaking012Result *fortastaking012.FortaStakingAccessManagerUpdatedIterator

}

// FilterAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterAccessManagerUpdated(opts *bind.FilterOpts, newAddressManager []common.Address) (retVal *FilterAccessManagerUpdatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterAccessManagerUpdatedOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterAccessManagerUpdated(opts, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterAccessManagerUpdated(opts, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchAccessManagerUpdated(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingAccessManagerUpdated, newAddressManager []common.Address, sinkAlt1 chan<- *fortastaking012.FortaStakingAccessManagerUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchAccessManagerUpdated(opts, sink, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchAccessManagerUpdated(opts, sinkAlt1, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingAccessManagerUpdated is a merged return type.
type FortaStakingAccessManagerUpdated struct {

	NewAddressManager common.Address

	Raw types.Log

}

// ParseAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseAccessManagerUpdated(log types.Log) (retVal *FortaStakingAccessManagerUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingAccessManagerUpdated{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseAccessManagerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.NewAddressManager = val.NewAddressManager

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseAccessManagerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.NewAddressManager = val.NewAddressManager

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// FilterAdminChangedOutput is a merged return type.
type FilterAdminChangedOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingAdminChangedIterator

	Fortastaking012Result *fortastaking012.FortaStakingAdminChangedIterator

}

// FilterAdminChanged multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterAdminChanged(opts *bind.FilterOpts) (retVal *FilterAdminChangedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterAdminChangedOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterAdminChanged(opts)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterAdminChanged(opts)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}



// WatchAdminChanged multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchAdminChanged(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingAdminChanged, sinkAlt2 chan<- *fortastaking012.FortaStakingAdminChanged) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchAdminChanged(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchAdminChanged(opts, sinkAlt2)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingAdminChanged is a merged return type.
type FortaStakingAdminChanged struct {

	PreviousAdmin common.Address

	NewAdmin common.Address

	Raw types.Log

}

// ParseAdminChanged multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseAdminChanged(log types.Log) (retVal *FortaStakingAdminChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingAdminChanged{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseAdminChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseAdminChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}


// FilterApprovalForAllOutput is a merged return type.
type FilterApprovalForAllOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingApprovalForAllIterator

	Fortastaking012Result *fortastaking012.FortaStakingApprovalForAllIterator

}

// FilterApprovalForAll multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterApprovalForAll(opts *bind.FilterOpts, account []common.Address, operator []common.Address) (retVal *FilterApprovalForAllOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterApprovalForAllOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterApprovalForAll(opts, account, operator)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterApprovalForAll(opts, account, operator)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}



// WatchApprovalForAll multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingApprovalForAll, account []common.Address, operator []common.Address, sinkAlt3 chan<- *fortastaking012.FortaStakingApprovalForAll) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchApprovalForAll(opts, sink, account, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchApprovalForAll(opts, sinkAlt3, account, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingApprovalForAll is a merged return type.
type FortaStakingApprovalForAll struct {

	Account common.Address

	Operator common.Address

	Approved bool

	Raw types.Log

}

// ParseApprovalForAll multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseApprovalForAll(log types.Log) (retVal *FortaStakingApprovalForAll, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingApprovalForAll{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseApprovalForAll(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Account = val.Account

		retVal.Operator = val.Operator

		retVal.Approved = val.Approved

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseApprovalForAll(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Account = val.Account

		retVal.Operator = val.Operator

		retVal.Approved = val.Approved

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}


// FilterBeaconUpgradedOutput is a merged return type.
type FilterBeaconUpgradedOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingBeaconUpgradedIterator

	Fortastaking012Result *fortastaking012.FortaStakingBeaconUpgradedIterator

}

// FilterBeaconUpgraded multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterBeaconUpgraded(opts *bind.FilterOpts, beacon []common.Address) (retVal *FilterBeaconUpgradedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterBeaconUpgradedOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterBeaconUpgraded(opts, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterBeaconUpgraded(opts, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// WatchBeaconUpgraded multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchBeaconUpgraded(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingBeaconUpgraded, beacon []common.Address, sinkAlt4 chan<- *fortastaking012.FortaStakingBeaconUpgraded) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchBeaconUpgraded(opts, sink, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchBeaconUpgraded(opts, sinkAlt4, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingBeaconUpgraded is a merged return type.
type FortaStakingBeaconUpgraded struct {

	Beacon common.Address

	Raw types.Log

}

// ParseBeaconUpgraded multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseBeaconUpgraded(log types.Log) (retVal *FortaStakingBeaconUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingBeaconUpgraded{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseBeaconUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseBeaconUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// FilterDelaySetOutput is a merged return type.
type FilterDelaySetOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingDelaySetIterator

	Fortastaking012Result *fortastaking012.FortaStakingDelaySetIterator

}

// FilterDelaySet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterDelaySet(opts *bind.FilterOpts) (retVal *FilterDelaySetOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterDelaySetOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterDelaySet(opts)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterDelaySet(opts)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterDelaySet not implemented (tag=%s)", merged.currTag)
	return
}



// WatchDelaySet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchDelaySet(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingDelaySet, sinkAlt5 chan<- *fortastaking012.FortaStakingDelaySet) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchDelaySet(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchDelaySet(opts, sinkAlt5)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchDelaySet not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingDelaySet is a merged return type.
type FortaStakingDelaySet struct {

	NewWithdrawalDelay *big.Int

	Raw types.Log

}

// ParseDelaySet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseDelaySet(log types.Log) (retVal *FortaStakingDelaySet, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingDelaySet{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseDelaySet(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.NewWithdrawalDelay = val.NewWithdrawalDelay

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseDelaySet(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.NewWithdrawalDelay = val.NewWithdrawalDelay

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseDelaySet not implemented (tag=%s)", merged.currTag)
	return
}


// FilterFrozeOutput is a merged return type.
type FilterFrozeOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingFrozeIterator

	Fortastaking012Result *fortastaking012.FortaStakingFrozeIterator

}

// FilterFroze multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterFroze(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, by []common.Address) (retVal *FilterFrozeOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterFrozeOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterFroze(opts, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterFroze(opts, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterFroze not implemented (tag=%s)", merged.currTag)
	return
}



// WatchFroze multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchFroze(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingFroze, subjectType []uint8, subject []*big.Int, by []common.Address, sinkAlt6 chan<- *fortastaking012.FortaStakingFroze) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchFroze(opts, sink, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchFroze(opts, sinkAlt6, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchFroze not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingFroze is a merged return type.
type FortaStakingFroze struct {

	SubjectType uint8

	Subject *big.Int

	By common.Address

	IsFrozen bool

	Raw types.Log

}

// ParseFroze multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseFroze(log types.Log) (retVal *FortaStakingFroze, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingFroze{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseFroze(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.By = val.By

		retVal.IsFrozen = val.IsFrozen

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseFroze(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.By = val.By

		retVal.IsFrozen = val.IsFrozen

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseFroze not implemented (tag=%s)", merged.currTag)
	return
}


// FilterInitializedOutput is a merged return type.
type FilterInitializedOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingInitializedIterator

	Fortastaking012Result *fortastaking012.FortaStakingInitializedIterator

}

// FilterInitialized multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterInitialized(opts *bind.FilterOpts) (retVal *FilterInitializedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterInitializedOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterInitialized(opts)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterInitialized(opts)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterInitialized not implemented (tag=%s)", merged.currTag)
	return
}



// WatchInitialized multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingInitialized, sinkAlt7 chan<- *fortastaking012.FortaStakingInitialized) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchInitialized(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchInitialized(opts, sinkAlt7)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchInitialized not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingInitialized is a merged return type.
type FortaStakingInitialized struct {

	Version uint8

	Raw types.Log

}

// ParseInitialized multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseInitialized(log types.Log) (retVal *FortaStakingInitialized, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingInitialized{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseInitialized(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Version = val.Version

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseInitialized(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Version = val.Version

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseInitialized not implemented (tag=%s)", merged.currTag)
	return
}


// FilterMaxStakeReachedOutput is a merged return type.
type FilterMaxStakeReachedOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingMaxStakeReachedIterator

	Fortastaking012Result *fortastaking012.FortaStakingMaxStakeReachedIterator

}

// FilterMaxStakeReached multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterMaxStakeReached(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int) (retVal *FilterMaxStakeReachedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterMaxStakeReachedOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterMaxStakeReached(opts, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterMaxStakeReached(opts, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterMaxStakeReached not implemented (tag=%s)", merged.currTag)
	return
}



// WatchMaxStakeReached multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchMaxStakeReached(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingMaxStakeReached, subjectType []uint8, subject []*big.Int, sinkAlt8 chan<- *fortastaking012.FortaStakingMaxStakeReached) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchMaxStakeReached(opts, sink, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchMaxStakeReached(opts, sinkAlt8, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchMaxStakeReached not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingMaxStakeReached is a merged return type.
type FortaStakingMaxStakeReached struct {

	SubjectType uint8

	Subject *big.Int

	Raw types.Log

}

// ParseMaxStakeReached multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseMaxStakeReached(log types.Log) (retVal *FortaStakingMaxStakeReached, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingMaxStakeReached{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseMaxStakeReached(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseMaxStakeReached(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseMaxStakeReached not implemented (tag=%s)", merged.currTag)
	return
}



// FilterReleased multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterReleased(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, to []common.Address) (retVal *fortastaking011.FortaStakingReleasedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterReleased(opts, subjectType, subject, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterReleased not implemented (tag=%s)", merged.currTag)
	return
}



// WatchReleased multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchReleased(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingReleased, subjectType []uint8, subject []*big.Int, to []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchReleased(opts, sink, subjectType, subject, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchReleased not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingReleased is a merged return type.
type FortaStakingReleased struct {

	SubjectType uint8

	Subject *big.Int

	To common.Address

	Value *big.Int

	Raw types.Log

}

// ParseReleased multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseReleased(log types.Log) (retVal *FortaStakingReleased, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingReleased{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseReleased(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.To = val.To

		retVal.Value = val.Value

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseReleased not implemented (tag=%s)", merged.currTag)
	return
}



// FilterRewarded multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterRewarded(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, from []common.Address) (retVal *fortastaking011.FortaStakingRewardedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterRewarded(opts, subjectType, subject, from)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterRewarded not implemented (tag=%s)", merged.currTag)
	return
}



// WatchRewarded multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchRewarded(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingRewarded, subjectType []uint8, subject []*big.Int, from []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchRewarded(opts, sink, subjectType, subject, from)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchRewarded not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingRewarded is a merged return type.
type FortaStakingRewarded struct {

	SubjectType uint8

	Subject *big.Int

	From common.Address

	Value *big.Int

	Raw types.Log

}

// ParseRewarded multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseRewarded(log types.Log) (retVal *FortaStakingRewarded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingRewarded{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseRewarded(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.From = val.From

		retVal.Value = val.Value

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseRewarded not implemented (tag=%s)", merged.currTag)
	return
}


// FilterRouterUpdatedOutput is a merged return type.
type FilterRouterUpdatedOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingRouterUpdatedIterator

	Fortastaking012Result *fortastaking012.FortaStakingRouterUpdatedIterator

}

// FilterRouterUpdated multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterRouterUpdated(opts *bind.FilterOpts, router []common.Address) (retVal *FilterRouterUpdatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterRouterUpdatedOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterRouterUpdated(opts, router)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterRouterUpdated(opts, router)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchRouterUpdated multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchRouterUpdated(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingRouterUpdated, router []common.Address, sinkAlt9 chan<- *fortastaking012.FortaStakingRouterUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchRouterUpdated(opts, sink, router)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchRouterUpdated(opts, sinkAlt9, router)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingRouterUpdated is a merged return type.
type FortaStakingRouterUpdated struct {

	Router common.Address

	Raw types.Log

}

// ParseRouterUpdated multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseRouterUpdated(log types.Log) (retVal *FortaStakingRouterUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingRouterUpdated{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseRouterUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Router = val.Router

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseRouterUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Router = val.Router

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}


// FilterSlashedOutput is a merged return type.
type FilterSlashedOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingSlashedIterator

	Fortastaking012Result *fortastaking012.FortaStakingSlashedIterator

}

// FilterSlashed multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterSlashed(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, by []common.Address) (retVal *FilterSlashedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterSlashedOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterSlashed(opts, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterSlashed(opts, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterSlashed not implemented (tag=%s)", merged.currTag)
	return
}



// WatchSlashed multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchSlashed(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingSlashed, subjectType []uint8, subject []*big.Int, by []common.Address, sinkAlt10 chan<- *fortastaking012.FortaStakingSlashed) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchSlashed(opts, sink, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchSlashed(opts, sinkAlt10, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchSlashed not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingSlashed is a merged return type.
type FortaStakingSlashed struct {

	SubjectType uint8

	Subject *big.Int

	By common.Address

	Value *big.Int

	Raw types.Log

}

// ParseSlashed multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseSlashed(log types.Log) (retVal *FortaStakingSlashed, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingSlashed{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseSlashed(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.By = val.By

		retVal.Value = val.Value

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseSlashed(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.By = val.By

		retVal.Value = val.Value

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseSlashed not implemented (tag=%s)", merged.currTag)
	return
}


// FilterSlashedShareSentOutput is a merged return type.
type FilterSlashedShareSentOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingSlashedShareSentIterator

	Fortastaking012Result *fortastaking012.FortaStakingSlashedShareSentIterator

}

// FilterSlashedShareSent multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterSlashedShareSent(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, by []common.Address) (retVal *FilterSlashedShareSentOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterSlashedShareSentOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterSlashedShareSent(opts, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterSlashedShareSent(opts, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterSlashedShareSent not implemented (tag=%s)", merged.currTag)
	return
}



// WatchSlashedShareSent multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchSlashedShareSent(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingSlashedShareSent, subjectType []uint8, subject []*big.Int, by []common.Address, sinkAlt11 chan<- *fortastaking012.FortaStakingSlashedShareSent) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchSlashedShareSent(opts, sink, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchSlashedShareSent(opts, sinkAlt11, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchSlashedShareSent not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingSlashedShareSent is a merged return type.
type FortaStakingSlashedShareSent struct {

	SubjectType uint8

	Subject *big.Int

	By common.Address

	Value *big.Int

	Raw types.Log

}

// ParseSlashedShareSent multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseSlashedShareSent(log types.Log) (retVal *FortaStakingSlashedShareSent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingSlashedShareSent{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseSlashedShareSent(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.By = val.By

		retVal.Value = val.Value

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseSlashedShareSent(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.By = val.By

		retVal.Value = val.Value

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseSlashedShareSent not implemented (tag=%s)", merged.currTag)
	return
}


// FilterStakeDepositedOutput is a merged return type.
type FilterStakeDepositedOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingStakeDepositedIterator

	Fortastaking012Result *fortastaking012.FortaStakingStakeDepositedIterator

}

// FilterStakeDeposited multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterStakeDeposited(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, account []common.Address) (retVal *FilterStakeDepositedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterStakeDepositedOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterStakeDeposited(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterStakeDeposited(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterStakeDeposited not implemented (tag=%s)", merged.currTag)
	return
}



// WatchStakeDeposited multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchStakeDeposited(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingStakeDeposited, subjectType []uint8, subject []*big.Int, account []common.Address, sinkAlt12 chan<- *fortastaking012.FortaStakingStakeDeposited) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchStakeDeposited(opts, sink, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchStakeDeposited(opts, sinkAlt12, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchStakeDeposited not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingStakeDeposited is a merged return type.
type FortaStakingStakeDeposited struct {

	SubjectType uint8

	Subject *big.Int

	Account common.Address

	Amount *big.Int

	Raw types.Log

}

// ParseStakeDeposited multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseStakeDeposited(log types.Log) (retVal *FortaStakingStakeDeposited, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingStakeDeposited{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseStakeDeposited(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Account = val.Account

		retVal.Amount = val.Amount

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseStakeDeposited(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Account = val.Account

		retVal.Amount = val.Amount

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseStakeDeposited not implemented (tag=%s)", merged.currTag)
	return
}



// FilterStakeParamsManagerSet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterStakeParamsManagerSet(opts *bind.FilterOpts, newManager []common.Address) (retVal *fortastaking011.FortaStakingStakeParamsManagerSetIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterStakeParamsManagerSet(opts, newManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterStakeParamsManagerSet not implemented (tag=%s)", merged.currTag)
	return
}



// WatchStakeParamsManagerSet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchStakeParamsManagerSet(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingStakeParamsManagerSet, newManager []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchStakeParamsManagerSet(opts, sink, newManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchStakeParamsManagerSet not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingStakeParamsManagerSet is a merged return type.
type FortaStakingStakeParamsManagerSet struct {

	NewManager common.Address

	Raw types.Log

}

// ParseStakeParamsManagerSet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseStakeParamsManagerSet(log types.Log) (retVal *FortaStakingStakeParamsManagerSet, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingStakeParamsManagerSet{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseStakeParamsManagerSet(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.NewManager = val.NewManager

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseStakeParamsManagerSet not implemented (tag=%s)", merged.currTag)
	return
}


// FilterTokensSweptOutput is a merged return type.
type FilterTokensSweptOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingTokensSweptIterator

	Fortastaking012Result *fortastaking012.FortaStakingTokensSweptIterator

}

// FilterTokensSwept multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterTokensSwept(opts *bind.FilterOpts, token []common.Address) (retVal *FilterTokensSweptOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterTokensSweptOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterTokensSwept(opts, token)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterTokensSwept(opts, token)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterTokensSwept not implemented (tag=%s)", merged.currTag)
	return
}



// WatchTokensSwept multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchTokensSwept(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingTokensSwept, token []common.Address, sinkAlt13 chan<- *fortastaking012.FortaStakingTokensSwept) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchTokensSwept(opts, sink, token)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchTokensSwept(opts, sinkAlt13, token)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchTokensSwept not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingTokensSwept is a merged return type.
type FortaStakingTokensSwept struct {

	Token common.Address

	To common.Address

	Amount *big.Int

	Raw types.Log

}

// ParseTokensSwept multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseTokensSwept(log types.Log) (retVal *FortaStakingTokensSwept, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingTokensSwept{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseTokensSwept(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Token = val.Token

		retVal.To = val.To

		retVal.Amount = val.Amount

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseTokensSwept(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Token = val.Token

		retVal.To = val.To

		retVal.Amount = val.Amount

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseTokensSwept not implemented (tag=%s)", merged.currTag)
	return
}


// FilterTransferBatchOutput is a merged return type.
type FilterTransferBatchOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingTransferBatchIterator

	Fortastaking012Result *fortastaking012.FortaStakingTransferBatchIterator

}

// FilterTransferBatch multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterTransferBatch(opts *bind.FilterOpts, operator []common.Address, from []common.Address, to []common.Address) (retVal *FilterTransferBatchOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterTransferBatchOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterTransferBatch(opts, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterTransferBatch(opts, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterTransferBatch not implemented (tag=%s)", merged.currTag)
	return
}



// WatchTransferBatch multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchTransferBatch(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingTransferBatch, operator []common.Address, from []common.Address, to []common.Address, sinkAlt14 chan<- *fortastaking012.FortaStakingTransferBatch) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchTransferBatch(opts, sink, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchTransferBatch(opts, sinkAlt14, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchTransferBatch not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingTransferBatch is a merged return type.
type FortaStakingTransferBatch struct {

	Operator common.Address

	From common.Address

	To common.Address

	Ids []*big.Int

	Values []*big.Int

	Raw types.Log

}

// ParseTransferBatch multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseTransferBatch(log types.Log) (retVal *FortaStakingTransferBatch, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingTransferBatch{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseTransferBatch(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Operator = val.Operator

		retVal.From = val.From

		retVal.To = val.To

		retVal.Ids = val.Ids

		retVal.Values = val.Values

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseTransferBatch(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Operator = val.Operator

		retVal.From = val.From

		retVal.To = val.To

		retVal.Ids = val.Ids

		retVal.Values = val.Values

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseTransferBatch not implemented (tag=%s)", merged.currTag)
	return
}


// FilterTransferSingleOutput is a merged return type.
type FilterTransferSingleOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingTransferSingleIterator

	Fortastaking012Result *fortastaking012.FortaStakingTransferSingleIterator

}

// FilterTransferSingle multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterTransferSingle(opts *bind.FilterOpts, operator []common.Address, from []common.Address, to []common.Address) (retVal *FilterTransferSingleOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterTransferSingleOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterTransferSingle(opts, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterTransferSingle(opts, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterTransferSingle not implemented (tag=%s)", merged.currTag)
	return
}



// WatchTransferSingle multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchTransferSingle(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingTransferSingle, operator []common.Address, from []common.Address, to []common.Address, sinkAlt15 chan<- *fortastaking012.FortaStakingTransferSingle) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchTransferSingle(opts, sink, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchTransferSingle(opts, sinkAlt15, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchTransferSingle not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingTransferSingle is a merged return type.
type FortaStakingTransferSingle struct {

	Operator common.Address

	From common.Address

	To common.Address

	Id *big.Int

	Value *big.Int

	Raw types.Log

}

// ParseTransferSingle multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseTransferSingle(log types.Log) (retVal *FortaStakingTransferSingle, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingTransferSingle{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseTransferSingle(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Operator = val.Operator

		retVal.From = val.From

		retVal.To = val.To

		retVal.Id = val.Id

		retVal.Value = val.Value

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseTransferSingle(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Operator = val.Operator

		retVal.From = val.From

		retVal.To = val.To

		retVal.Id = val.Id

		retVal.Value = val.Value

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseTransferSingle not implemented (tag=%s)", merged.currTag)
	return
}


// FilterTreasurySetOutput is a merged return type.
type FilterTreasurySetOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingTreasurySetIterator

	Fortastaking012Result *fortastaking012.FortaStakingTreasurySetIterator

}

// FilterTreasurySet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterTreasurySet(opts *bind.FilterOpts) (retVal *FilterTreasurySetOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterTreasurySetOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterTreasurySet(opts)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterTreasurySet(opts)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterTreasurySet not implemented (tag=%s)", merged.currTag)
	return
}



// WatchTreasurySet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchTreasurySet(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingTreasurySet, sinkAlt16 chan<- *fortastaking012.FortaStakingTreasurySet) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchTreasurySet(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchTreasurySet(opts, sinkAlt16)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchTreasurySet not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingTreasurySet is a merged return type.
type FortaStakingTreasurySet struct {

	NewTreasury common.Address

	Raw types.Log

}

// ParseTreasurySet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseTreasurySet(log types.Log) (retVal *FortaStakingTreasurySet, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingTreasurySet{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseTreasurySet(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.NewTreasury = val.NewTreasury

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseTreasurySet(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.NewTreasury = val.NewTreasury

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseTreasurySet not implemented (tag=%s)", merged.currTag)
	return
}


// FilterURIOutput is a merged return type.
type FilterURIOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingURIIterator

	Fortastaking012Result *fortastaking012.FortaStakingURIIterator

}

// FilterURI multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterURI(opts *bind.FilterOpts, id []*big.Int) (retVal *FilterURIOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterURIOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterURI(opts, id)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterURI(opts, id)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterURI not implemented (tag=%s)", merged.currTag)
	return
}



// WatchURI multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchURI(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingURI, id []*big.Int, sinkAlt17 chan<- *fortastaking012.FortaStakingURI) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchURI(opts, sink, id)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchURI(opts, sinkAlt17, id)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchURI not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingURI is a merged return type.
type FortaStakingURI struct {

	Value string

	Id *big.Int

	Raw types.Log

}

// ParseURI multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseURI(log types.Log) (retVal *FortaStakingURI, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingURI{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseURI(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Value = val.Value

		retVal.Id = val.Id

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseURI(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Value = val.Value

		retVal.Id = val.Id

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseURI not implemented (tag=%s)", merged.currTag)
	return
}


// FilterUpgradedOutput is a merged return type.
type FilterUpgradedOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingUpgradedIterator

	Fortastaking012Result *fortastaking012.FortaStakingUpgradedIterator

}

// FilterUpgraded multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterUpgraded(opts *bind.FilterOpts, implementation []common.Address) (retVal *FilterUpgradedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterUpgradedOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterUpgraded(opts, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterUpgraded(opts, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterUpgraded not implemented (tag=%s)", merged.currTag)
	return
}



// WatchUpgraded multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchUpgraded(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingUpgraded, implementation []common.Address, sinkAlt18 chan<- *fortastaking012.FortaStakingUpgraded) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchUpgraded(opts, sink, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchUpgraded(opts, sinkAlt18, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingUpgraded is a merged return type.
type FortaStakingUpgraded struct {

	Implementation common.Address

	Raw types.Log

}

// ParseUpgraded multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseUpgraded(log types.Log) (retVal *FortaStakingUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingUpgraded{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseUpgraded not implemented (tag=%s)", merged.currTag)
	return
}


// FilterWithdrawalExecutedOutput is a merged return type.
type FilterWithdrawalExecutedOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingWithdrawalExecutedIterator

	Fortastaking012Result *fortastaking012.FortaStakingWithdrawalExecutedIterator

}

// FilterWithdrawalExecuted multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterWithdrawalExecuted(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, account []common.Address) (retVal *FilterWithdrawalExecutedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterWithdrawalExecutedOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterWithdrawalExecuted(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterWithdrawalExecuted(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterWithdrawalExecuted not implemented (tag=%s)", merged.currTag)
	return
}



// WatchWithdrawalExecuted multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchWithdrawalExecuted(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingWithdrawalExecuted, subjectType []uint8, subject []*big.Int, account []common.Address, sinkAlt19 chan<- *fortastaking012.FortaStakingWithdrawalExecuted) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchWithdrawalExecuted(opts, sink, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchWithdrawalExecuted(opts, sinkAlt19, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchWithdrawalExecuted not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingWithdrawalExecuted is a merged return type.
type FortaStakingWithdrawalExecuted struct {

	SubjectType uint8

	Subject *big.Int

	Account common.Address

	Raw types.Log

}

// ParseWithdrawalExecuted multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseWithdrawalExecuted(log types.Log) (retVal *FortaStakingWithdrawalExecuted, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingWithdrawalExecuted{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseWithdrawalExecuted(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Account = val.Account

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseWithdrawalExecuted(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Account = val.Account

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseWithdrawalExecuted not implemented (tag=%s)", merged.currTag)
	return
}


// FilterWithdrawalInitiatedOutput is a merged return type.
type FilterWithdrawalInitiatedOutput struct {

	Fortastaking011Result *fortastaking011.FortaStakingWithdrawalInitiatedIterator

	Fortastaking012Result *fortastaking012.FortaStakingWithdrawalInitiatedIterator

}

// FilterWithdrawalInitiated multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterWithdrawalInitiated(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, account []common.Address) (retVal *FilterWithdrawalInitiatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FilterWithdrawalInitiatedOutput{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterWithdrawalInitiated(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking011Result = val


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterWithdrawalInitiated(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Fortastaking012Result = val


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterWithdrawalInitiated not implemented (tag=%s)", merged.currTag)
	return
}



// WatchWithdrawalInitiated multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchWithdrawalInitiated(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingWithdrawalInitiated, subjectType []uint8, subject []*big.Int, account []common.Address, sinkAlt20 chan<- *fortastaking012.FortaStakingWithdrawalInitiated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchWithdrawalInitiated(opts, sink, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchWithdrawalInitiated(opts, sinkAlt20, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchWithdrawalInitiated not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingWithdrawalInitiated is a merged return type.
type FortaStakingWithdrawalInitiated struct {

	SubjectType uint8

	Subject *big.Int

	Account common.Address

	Deadline uint64

	Raw types.Log

}

// ParseWithdrawalInitiated multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseWithdrawalInitiated(log types.Log) (retVal *FortaStakingWithdrawalInitiated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingWithdrawalInitiated{}



	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseWithdrawalInitiated(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Account = val.Account

		retVal.Deadline = val.Deadline

		retVal.Raw = val.Raw


		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseWithdrawalInitiated(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Account = val.Account

		retVal.Deadline = val.Deadline

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseWithdrawalInitiated not implemented (tag=%s)", merged.currTag)
	return
}



// FilterSlashDelegatorsPercentSet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterSlashDelegatorsPercentSet(opts *bind.FilterOpts) (retVal *fortastaking012.FortaStakingSlashDelegatorsPercentSetIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterSlashDelegatorsPercentSet(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterSlashDelegatorsPercentSet not implemented (tag=%s)", merged.currTag)
	return
}



// WatchSlashDelegatorsPercentSet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchSlashDelegatorsPercentSet(opts *bind.WatchOpts, sink chan<- *fortastaking012.FortaStakingSlashDelegatorsPercentSet) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchSlashDelegatorsPercentSet(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchSlashDelegatorsPercentSet not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingSlashDelegatorsPercentSet is a merged return type.
type FortaStakingSlashDelegatorsPercentSet struct {

	Percent *big.Int

	Raw types.Log

}

// ParseSlashDelegatorsPercentSet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseSlashDelegatorsPercentSet(log types.Log) (retVal *FortaStakingSlashDelegatorsPercentSet, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingSlashDelegatorsPercentSet{}



	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseSlashDelegatorsPercentSet(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.Percent = val.Percent

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseSlashDelegatorsPercentSet not implemented (tag=%s)", merged.currTag)
	return
}



// FilterStakeHelpersConfigured multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterStakeHelpersConfigured(opts *bind.FilterOpts, subjectGateway []common.Address, allocator []common.Address) (retVal *fortastaking012.FortaStakingStakeHelpersConfiguredIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterStakeHelpersConfigured(opts, subjectGateway, allocator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.FilterStakeHelpersConfigured not implemented (tag=%s)", merged.currTag)
	return
}



// WatchStakeHelpersConfigured multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchStakeHelpersConfigured(opts *bind.WatchOpts, sink chan<- *fortastaking012.FortaStakingStakeHelpersConfigured, subjectGateway []common.Address, allocator []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}




	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchStakeHelpersConfigured(opts, sink, subjectGateway, allocator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.WatchStakeHelpersConfigured not implemented (tag=%s)", merged.currTag)
	return
}


// FortaStakingStakeHelpersConfigured is a merged return type.
type FortaStakingStakeHelpersConfigured struct {

	SubjectGateway common.Address

	Allocator common.Address

	Raw types.Log

}

// ParseStakeHelpersConfigured multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseStakeHelpersConfigured(log types.Log) (retVal *FortaStakingStakeHelpersConfigured, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}


	retVal = &FortaStakingStakeHelpersConfigured{}



	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseStakeHelpersConfigured(log)

		if methodErr != nil {
			err = methodErr
			return
		}


		retVal.SubjectGateway = val.SubjectGateway

		retVal.Allocator = val.Allocator

		retVal.Raw = val.Raw


		return
	}


	err = import_fmt.Errorf("FortaStakingFilterer.ParseStakeHelpersConfigured not implemented (tag=%s)", merged.currTag)
	return
}