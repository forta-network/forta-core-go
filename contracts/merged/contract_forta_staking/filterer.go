// Code generated by go-merge-types. DO NOT EDIT.

package contract_forta_staking

import (
	import_fmt "fmt"
	import_sync "sync"

	fortastaking011 "github.com/forta-network/forta-core-go/contracts/generated/contract_forta_staking_0_1_1"

	fortastaking012 "github.com/forta-network/forta-core-go/contracts/generated/contract_forta_staking_0_1_2"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"

	"github.com/ethereum/go-ethereum/event"

	"github.com/ethereum/go-ethereum/core/types"

	"github.com/ethereum/go-ethereum/common"

	"math/big"
)

// FortaStakingFilterer is a new type which can multiplex calls to different implementation types.
type FortaStakingFilterer struct {
	typ0 *fortastaking011.FortaStakingFilterer

	typ1 *fortastaking012.FortaStakingFilterer

	currTag string
	mu      import_sync.RWMutex
	unsafe  bool // default: false
}

// NewFortaStakingFilterer creates a new merged type.
func NewFortaStakingFilterer(address common.Address, filterer bind.ContractFilterer) (*FortaStakingFilterer, error) {
	var (
		mergedType FortaStakingFilterer
		err        error
	)
	mergedType.currTag = "0.1.2"

	mergedType.typ0, err = fortastaking011.NewFortaStakingFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize fortastaking011.FortaStakingFilterer: %v", err)
	}

	mergedType.typ1, err = fortastaking012.NewFortaStakingFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize fortastaking012.FortaStakingFilterer: %v", err)
	}

	return &mergedType, nil
}

// IsKnownTagForFortaStakingFilterer tells if given tag is a known tag.
func IsKnownTagForFortaStakingFilterer(tag string) bool {

	if tag == "0.1.1" {
		return true
	}

	if tag == "0.1.2" {
		return true
	}

	return false
}

// Use sets the used implementation to given tag.
func (merged *FortaStakingFilterer) Use(tag string) (changed bool) {
	if !merged.unsafe {
		merged.mu.Lock()
		defer merged.mu.Unlock()
	}
	// use the default tag if the provided tag is unknown
	if !IsKnownTagForFortaStakingFilterer(tag) {
		tag = "0.1.2"
	}
	changed = merged.currTag != tag
	merged.currTag = tag
	return
}

// Unsafe disables the mutex.
func (merged *FortaStakingFilterer) Unsafe() {
	merged.unsafe = true
}

// Safe enables the mutex.
func (merged *FortaStakingFilterer) Safe() {
	merged.unsafe = false
}

// FilterAccessManagerUpdatedOutput is a merged return type.
type FilterAccessManagerUpdatedOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingAccessManagerUpdatedIterator

	Fortastaking012Result *fortastaking012.FortaStakingAccessManagerUpdatedIterator
}

// FilterAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterAccessManagerUpdated(opts *bind.FilterOpts, newAddressManager []common.Address) (retVal *FilterAccessManagerUpdatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterAccessManagerUpdatedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterAccessManagerUpdated(opts, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterAccessManagerUpdated(opts, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// WatchAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchAccessManagerUpdated(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingAccessManagerUpdated, newAddressManager []common.Address, sinkAlt1 chan<- *fortastaking012.FortaStakingAccessManagerUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchAccessManagerUpdated(opts, sink, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchAccessManagerUpdated(opts, sinkAlt1, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingAccessManagerUpdated is a merged return type.
type FortaStakingAccessManagerUpdated struct {
	NewAddressManager common.Address

	Raw types.Log
}

// ParseAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseAccessManagerUpdated(log types.Log) (retVal *FortaStakingAccessManagerUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingAccessManagerUpdated{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseAccessManagerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewAddressManager = val.NewAddressManager

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseAccessManagerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewAddressManager = val.NewAddressManager

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// FilterAdminChangedOutput is a merged return type.
type FilterAdminChangedOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingAdminChangedIterator

	Fortastaking012Result *fortastaking012.FortaStakingAdminChangedIterator
}

// FilterAdminChanged multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterAdminChanged(opts *bind.FilterOpts) (retVal *FilterAdminChangedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterAdminChangedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterAdminChanged(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterAdminChanged(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}

// WatchAdminChanged multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchAdminChanged(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingAdminChanged, sinkAlt2 chan<- *fortastaking012.FortaStakingAdminChanged) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchAdminChanged(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchAdminChanged(opts, sinkAlt2)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingAdminChanged is a merged return type.
type FortaStakingAdminChanged struct {
	PreviousAdmin common.Address

	NewAdmin common.Address

	Raw types.Log
}

// ParseAdminChanged multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseAdminChanged(log types.Log) (retVal *FortaStakingAdminChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingAdminChanged{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseAdminChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseAdminChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}

// FilterApprovalForAllOutput is a merged return type.
type FilterApprovalForAllOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingApprovalForAllIterator

	Fortastaking012Result *fortastaking012.FortaStakingApprovalForAllIterator
}

// FilterApprovalForAll multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterApprovalForAll(opts *bind.FilterOpts, account []common.Address, operator []common.Address) (retVal *FilterApprovalForAllOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterApprovalForAllOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterApprovalForAll(opts, account, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterApprovalForAll(opts, account, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}

// WatchApprovalForAll multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingApprovalForAll, account []common.Address, operator []common.Address, sinkAlt3 chan<- *fortastaking012.FortaStakingApprovalForAll) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchApprovalForAll(opts, sink, account, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchApprovalForAll(opts, sinkAlt3, account, operator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingApprovalForAll is a merged return type.
type FortaStakingApprovalForAll struct {
	Account common.Address

	Operator common.Address

	Approved bool

	Raw types.Log
}

// ParseApprovalForAll multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseApprovalForAll(log types.Log) (retVal *FortaStakingApprovalForAll, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingApprovalForAll{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseApprovalForAll(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Account = val.Account

		retVal.Operator = val.Operator

		retVal.Approved = val.Approved

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseApprovalForAll(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Account = val.Account

		retVal.Operator = val.Operator

		retVal.Approved = val.Approved

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseApprovalForAll not implemented (tag=%s)", merged.currTag)
	return
}

// FilterBeaconUpgradedOutput is a merged return type.
type FilterBeaconUpgradedOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingBeaconUpgradedIterator

	Fortastaking012Result *fortastaking012.FortaStakingBeaconUpgradedIterator
}

// FilterBeaconUpgraded multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterBeaconUpgraded(opts *bind.FilterOpts, beacon []common.Address) (retVal *FilterBeaconUpgradedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterBeaconUpgradedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterBeaconUpgraded(opts, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterBeaconUpgraded(opts, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// WatchBeaconUpgraded multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchBeaconUpgraded(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingBeaconUpgraded, beacon []common.Address, sinkAlt4 chan<- *fortastaking012.FortaStakingBeaconUpgraded) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchBeaconUpgraded(opts, sink, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchBeaconUpgraded(opts, sinkAlt4, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingBeaconUpgraded is a merged return type.
type FortaStakingBeaconUpgraded struct {
	Beacon common.Address

	Raw types.Log
}

// ParseBeaconUpgraded multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseBeaconUpgraded(log types.Log) (retVal *FortaStakingBeaconUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingBeaconUpgraded{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseBeaconUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseBeaconUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// FilterDelaySetOutput is a merged return type.
type FilterDelaySetOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingDelaySetIterator

	Fortastaking012Result *fortastaking012.FortaStakingDelaySetIterator
}

// FilterDelaySet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterDelaySet(opts *bind.FilterOpts) (retVal *FilterDelaySetOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterDelaySetOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterDelaySet(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterDelaySet(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterDelaySet not implemented (tag=%s)", merged.currTag)
	return
}

// WatchDelaySet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchDelaySet(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingDelaySet, sinkAlt5 chan<- *fortastaking012.FortaStakingDelaySet) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchDelaySet(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchDelaySet(opts, sinkAlt5)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchDelaySet not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingDelaySet is a merged return type.
type FortaStakingDelaySet struct {
	NewWithdrawalDelay *big.Int

	Raw types.Log
}

// ParseDelaySet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseDelaySet(log types.Log) (retVal *FortaStakingDelaySet, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingDelaySet{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseDelaySet(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewWithdrawalDelay = val.NewWithdrawalDelay

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseDelaySet(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewWithdrawalDelay = val.NewWithdrawalDelay

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseDelaySet not implemented (tag=%s)", merged.currTag)
	return
}

// FilterFrozeOutput is a merged return type.
type FilterFrozeOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingFrozeIterator

	Fortastaking012Result *fortastaking012.FortaStakingFrozeIterator
}

// FilterFroze multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterFroze(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, by []common.Address) (retVal *FilterFrozeOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterFrozeOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterFroze(opts, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterFroze(opts, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterFroze not implemented (tag=%s)", merged.currTag)
	return
}

// WatchFroze multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchFroze(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingFroze, subjectType []uint8, subject []*big.Int, by []common.Address, sinkAlt6 chan<- *fortastaking012.FortaStakingFroze) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchFroze(opts, sink, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchFroze(opts, sinkAlt6, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchFroze not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingFroze is a merged return type.
type FortaStakingFroze struct {
	SubjectType uint8

	Subject *big.Int

	By common.Address

	IsFrozen bool

	Raw types.Log
}

// ParseFroze multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseFroze(log types.Log) (retVal *FortaStakingFroze, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingFroze{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseFroze(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.By = val.By

		retVal.IsFrozen = val.IsFrozen

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseFroze(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.By = val.By

		retVal.IsFrozen = val.IsFrozen

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseFroze not implemented (tag=%s)", merged.currTag)
	return
}

// FilterInitializedOutput is a merged return type.
type FilterInitializedOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingInitializedIterator

	Fortastaking012Result *fortastaking012.FortaStakingInitializedIterator
}

// FilterInitialized multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterInitialized(opts *bind.FilterOpts) (retVal *FilterInitializedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterInitializedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterInitialized(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterInitialized(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterInitialized not implemented (tag=%s)", merged.currTag)
	return
}

// WatchInitialized multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingInitialized, sinkAlt7 chan<- *fortastaking012.FortaStakingInitialized) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchInitialized(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchInitialized(opts, sinkAlt7)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchInitialized not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingInitialized is a merged return type.
type FortaStakingInitialized struct {
	Version uint8

	Raw types.Log
}

// ParseInitialized multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseInitialized(log types.Log) (retVal *FortaStakingInitialized, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingInitialized{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseInitialized(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Version = val.Version

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseInitialized(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Version = val.Version

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseInitialized not implemented (tag=%s)", merged.currTag)
	return
}

// FilterMaxStakeReachedOutput is a merged return type.
type FilterMaxStakeReachedOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingMaxStakeReachedIterator

	Fortastaking012Result *fortastaking012.FortaStakingMaxStakeReachedIterator
}

// FilterMaxStakeReached multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterMaxStakeReached(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int) (retVal *FilterMaxStakeReachedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterMaxStakeReachedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterMaxStakeReached(opts, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterMaxStakeReached(opts, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterMaxStakeReached not implemented (tag=%s)", merged.currTag)
	return
}

// WatchMaxStakeReached multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchMaxStakeReached(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingMaxStakeReached, subjectType []uint8, subject []*big.Int, sinkAlt8 chan<- *fortastaking012.FortaStakingMaxStakeReached) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchMaxStakeReached(opts, sink, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchMaxStakeReached(opts, sinkAlt8, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchMaxStakeReached not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingMaxStakeReached is a merged return type.
type FortaStakingMaxStakeReached struct {
	SubjectType uint8

	Subject *big.Int

	Raw types.Log
}

// ParseMaxStakeReached multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseMaxStakeReached(log types.Log) (retVal *FortaStakingMaxStakeReached, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingMaxStakeReached{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseMaxStakeReached(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseMaxStakeReached(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseMaxStakeReached not implemented (tag=%s)", merged.currTag)
	return
}

// FilterReleased multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterReleased(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, to []common.Address) (retVal *fortastaking011.FortaStakingReleasedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterReleased(opts, subjectType, subject, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterReleased not implemented (tag=%s)", merged.currTag)
	return
}

// WatchReleased multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchReleased(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingReleased, subjectType []uint8, subject []*big.Int, to []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchReleased(opts, sink, subjectType, subject, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchReleased not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingReleased is a merged return type.
type FortaStakingReleased struct {
	SubjectType uint8

	Subject *big.Int

	To common.Address

	Value *big.Int

	Raw types.Log
}

// ParseReleased multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseReleased(log types.Log) (retVal *FortaStakingReleased, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingReleased{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseReleased(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.To = val.To

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseReleased not implemented (tag=%s)", merged.currTag)
	return
}

// FilterRewarded multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterRewarded(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, from []common.Address) (retVal *fortastaking011.FortaStakingRewardedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterRewarded(opts, subjectType, subject, from)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterRewarded not implemented (tag=%s)", merged.currTag)
	return
}

// WatchRewarded multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchRewarded(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingRewarded, subjectType []uint8, subject []*big.Int, from []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchRewarded(opts, sink, subjectType, subject, from)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchRewarded not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingRewarded is a merged return type.
type FortaStakingRewarded struct {
	SubjectType uint8

	Subject *big.Int

	From common.Address

	Value *big.Int

	Raw types.Log
}

// ParseRewarded multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseRewarded(log types.Log) (retVal *FortaStakingRewarded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingRewarded{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseRewarded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.From = val.From

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseRewarded not implemented (tag=%s)", merged.currTag)
	return
}

// FilterRouterUpdatedOutput is a merged return type.
type FilterRouterUpdatedOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingRouterUpdatedIterator

	Fortastaking012Result *fortastaking012.FortaStakingRouterUpdatedIterator
}

// FilterRouterUpdated multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterRouterUpdated(opts *bind.FilterOpts, router []common.Address) (retVal *FilterRouterUpdatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterRouterUpdatedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterRouterUpdated(opts, router)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterRouterUpdated(opts, router)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// WatchRouterUpdated multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchRouterUpdated(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingRouterUpdated, router []common.Address, sinkAlt9 chan<- *fortastaking012.FortaStakingRouterUpdated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchRouterUpdated(opts, sink, router)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchRouterUpdated(opts, sinkAlt9, router)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingRouterUpdated is a merged return type.
type FortaStakingRouterUpdated struct {
	Router common.Address

	Raw types.Log
}

// ParseRouterUpdated multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseRouterUpdated(log types.Log) (retVal *FortaStakingRouterUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingRouterUpdated{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseRouterUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Router = val.Router

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseRouterUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Router = val.Router

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// FilterSlashedOutput is a merged return type.
type FilterSlashedOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingSlashedIterator

	Fortastaking012Result *fortastaking012.FortaStakingSlashedIterator
}

// FilterSlashed multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterSlashed(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, by []common.Address) (retVal *FilterSlashedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterSlashedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterSlashed(opts, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterSlashed(opts, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterSlashed not implemented (tag=%s)", merged.currTag)
	return
}

// WatchSlashed multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchSlashed(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingSlashed, subjectType []uint8, subject []*big.Int, by []common.Address, sinkAlt10 chan<- *fortastaking012.FortaStakingSlashed) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchSlashed(opts, sink, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchSlashed(opts, sinkAlt10, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchSlashed not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingSlashed is a merged return type.
type FortaStakingSlashed struct {
	SubjectType uint8

	Subject *big.Int

	By common.Address

	Value *big.Int

	Raw types.Log
}

// ParseSlashed multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseSlashed(log types.Log) (retVal *FortaStakingSlashed, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingSlashed{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseSlashed(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.By = val.By

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseSlashed(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.By = val.By

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseSlashed not implemented (tag=%s)", merged.currTag)
	return
}

// FilterSlashedShareSentOutput is a merged return type.
type FilterSlashedShareSentOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingSlashedShareSentIterator

	Fortastaking012Result *fortastaking012.FortaStakingSlashedShareSentIterator
}

// FilterSlashedShareSent multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterSlashedShareSent(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, by []common.Address) (retVal *FilterSlashedShareSentOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterSlashedShareSentOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterSlashedShareSent(opts, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterSlashedShareSent(opts, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterSlashedShareSent not implemented (tag=%s)", merged.currTag)
	return
}

// WatchSlashedShareSent multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchSlashedShareSent(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingSlashedShareSent, subjectType []uint8, subject []*big.Int, by []common.Address, sinkAlt11 chan<- *fortastaking012.FortaStakingSlashedShareSent) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchSlashedShareSent(opts, sink, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchSlashedShareSent(opts, sinkAlt11, subjectType, subject, by)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchSlashedShareSent not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingSlashedShareSent is a merged return type.
type FortaStakingSlashedShareSent struct {
	SubjectType uint8

	Subject *big.Int

	By common.Address

	Value *big.Int

	Raw types.Log
}

// ParseSlashedShareSent multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseSlashedShareSent(log types.Log) (retVal *FortaStakingSlashedShareSent, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingSlashedShareSent{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseSlashedShareSent(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.By = val.By

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseSlashedShareSent(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.By = val.By

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseSlashedShareSent not implemented (tag=%s)", merged.currTag)
	return
}

// FilterStakeDepositedOutput is a merged return type.
type FilterStakeDepositedOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingStakeDepositedIterator

	Fortastaking012Result *fortastaking012.FortaStakingStakeDepositedIterator
}

// FilterStakeDeposited multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterStakeDeposited(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, account []common.Address) (retVal *FilterStakeDepositedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterStakeDepositedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterStakeDeposited(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterStakeDeposited(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterStakeDeposited not implemented (tag=%s)", merged.currTag)
	return
}

// WatchStakeDeposited multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchStakeDeposited(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingStakeDeposited, subjectType []uint8, subject []*big.Int, account []common.Address, sinkAlt12 chan<- *fortastaking012.FortaStakingStakeDeposited) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchStakeDeposited(opts, sink, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchStakeDeposited(opts, sinkAlt12, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchStakeDeposited not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingStakeDeposited is a merged return type.
type FortaStakingStakeDeposited struct {
	SubjectType uint8

	Subject *big.Int

	Account common.Address

	Amount *big.Int

	Raw types.Log
}

// ParseStakeDeposited multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseStakeDeposited(log types.Log) (retVal *FortaStakingStakeDeposited, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingStakeDeposited{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseStakeDeposited(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Account = val.Account

		retVal.Amount = val.Amount

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseStakeDeposited(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Account = val.Account

		retVal.Amount = val.Amount

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseStakeDeposited not implemented (tag=%s)", merged.currTag)
	return
}

// FilterStakeParamsManagerSet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterStakeParamsManagerSet(opts *bind.FilterOpts, newManager []common.Address) (retVal *fortastaking011.FortaStakingStakeParamsManagerSetIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterStakeParamsManagerSet(opts, newManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterStakeParamsManagerSet not implemented (tag=%s)", merged.currTag)
	return
}

// WatchStakeParamsManagerSet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchStakeParamsManagerSet(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingStakeParamsManagerSet, newManager []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchStakeParamsManagerSet(opts, sink, newManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchStakeParamsManagerSet not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingStakeParamsManagerSet is a merged return type.
type FortaStakingStakeParamsManagerSet struct {
	NewManager common.Address

	Raw types.Log
}

// ParseStakeParamsManagerSet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseStakeParamsManagerSet(log types.Log) (retVal *FortaStakingStakeParamsManagerSet, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingStakeParamsManagerSet{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseStakeParamsManagerSet(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewManager = val.NewManager

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseStakeParamsManagerSet not implemented (tag=%s)", merged.currTag)
	return
}

// FilterTokensSweptOutput is a merged return type.
type FilterTokensSweptOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingTokensSweptIterator

	Fortastaking012Result *fortastaking012.FortaStakingTokensSweptIterator
}

// FilterTokensSwept multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterTokensSwept(opts *bind.FilterOpts, token []common.Address) (retVal *FilterTokensSweptOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterTokensSweptOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterTokensSwept(opts, token)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterTokensSwept(opts, token)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterTokensSwept not implemented (tag=%s)", merged.currTag)
	return
}

// WatchTokensSwept multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchTokensSwept(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingTokensSwept, token []common.Address, sinkAlt13 chan<- *fortastaking012.FortaStakingTokensSwept) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchTokensSwept(opts, sink, token)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchTokensSwept(opts, sinkAlt13, token)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchTokensSwept not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingTokensSwept is a merged return type.
type FortaStakingTokensSwept struct {
	Token common.Address

	To common.Address

	Amount *big.Int

	Raw types.Log
}

// ParseTokensSwept multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseTokensSwept(log types.Log) (retVal *FortaStakingTokensSwept, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingTokensSwept{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseTokensSwept(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Token = val.Token

		retVal.To = val.To

		retVal.Amount = val.Amount

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseTokensSwept(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Token = val.Token

		retVal.To = val.To

		retVal.Amount = val.Amount

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseTokensSwept not implemented (tag=%s)", merged.currTag)
	return
}

// FilterTransferBatchOutput is a merged return type.
type FilterTransferBatchOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingTransferBatchIterator

	Fortastaking012Result *fortastaking012.FortaStakingTransferBatchIterator
}

// FilterTransferBatch multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterTransferBatch(opts *bind.FilterOpts, operator []common.Address, from []common.Address, to []common.Address) (retVal *FilterTransferBatchOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterTransferBatchOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterTransferBatch(opts, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterTransferBatch(opts, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterTransferBatch not implemented (tag=%s)", merged.currTag)
	return
}

// WatchTransferBatch multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchTransferBatch(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingTransferBatch, operator []common.Address, from []common.Address, to []common.Address, sinkAlt14 chan<- *fortastaking012.FortaStakingTransferBatch) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchTransferBatch(opts, sink, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchTransferBatch(opts, sinkAlt14, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchTransferBatch not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingTransferBatch is a merged return type.
type FortaStakingTransferBatch struct {
	Operator common.Address

	From common.Address

	To common.Address

	Ids []*big.Int

	Values []*big.Int

	Raw types.Log
}

// ParseTransferBatch multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseTransferBatch(log types.Log) (retVal *FortaStakingTransferBatch, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingTransferBatch{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseTransferBatch(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Operator = val.Operator

		retVal.From = val.From

		retVal.To = val.To

		retVal.Ids = val.Ids

		retVal.Values = val.Values

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseTransferBatch(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Operator = val.Operator

		retVal.From = val.From

		retVal.To = val.To

		retVal.Ids = val.Ids

		retVal.Values = val.Values

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseTransferBatch not implemented (tag=%s)", merged.currTag)
	return
}

// FilterTransferSingleOutput is a merged return type.
type FilterTransferSingleOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingTransferSingleIterator

	Fortastaking012Result *fortastaking012.FortaStakingTransferSingleIterator
}

// FilterTransferSingle multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterTransferSingle(opts *bind.FilterOpts, operator []common.Address, from []common.Address, to []common.Address) (retVal *FilterTransferSingleOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterTransferSingleOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterTransferSingle(opts, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterTransferSingle(opts, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterTransferSingle not implemented (tag=%s)", merged.currTag)
	return
}

// WatchTransferSingle multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchTransferSingle(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingTransferSingle, operator []common.Address, from []common.Address, to []common.Address, sinkAlt15 chan<- *fortastaking012.FortaStakingTransferSingle) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchTransferSingle(opts, sink, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchTransferSingle(opts, sinkAlt15, operator, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchTransferSingle not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingTransferSingle is a merged return type.
type FortaStakingTransferSingle struct {
	Operator common.Address

	From common.Address

	To common.Address

	Id *big.Int

	Value *big.Int

	Raw types.Log
}

// ParseTransferSingle multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseTransferSingle(log types.Log) (retVal *FortaStakingTransferSingle, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingTransferSingle{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseTransferSingle(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Operator = val.Operator

		retVal.From = val.From

		retVal.To = val.To

		retVal.Id = val.Id

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseTransferSingle(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Operator = val.Operator

		retVal.From = val.From

		retVal.To = val.To

		retVal.Id = val.Id

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseTransferSingle not implemented (tag=%s)", merged.currTag)
	return
}

// FilterTreasurySetOutput is a merged return type.
type FilterTreasurySetOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingTreasurySetIterator

	Fortastaking012Result *fortastaking012.FortaStakingTreasurySetIterator
}

// FilterTreasurySet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterTreasurySet(opts *bind.FilterOpts) (retVal *FilterTreasurySetOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterTreasurySetOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterTreasurySet(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterTreasurySet(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterTreasurySet not implemented (tag=%s)", merged.currTag)
	return
}

// WatchTreasurySet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchTreasurySet(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingTreasurySet, sinkAlt16 chan<- *fortastaking012.FortaStakingTreasurySet) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchTreasurySet(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchTreasurySet(opts, sinkAlt16)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchTreasurySet not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingTreasurySet is a merged return type.
type FortaStakingTreasurySet struct {
	NewTreasury common.Address

	Raw types.Log
}

// ParseTreasurySet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseTreasurySet(log types.Log) (retVal *FortaStakingTreasurySet, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingTreasurySet{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseTreasurySet(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewTreasury = val.NewTreasury

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseTreasurySet(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewTreasury = val.NewTreasury

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseTreasurySet not implemented (tag=%s)", merged.currTag)
	return
}

// FilterURIOutput is a merged return type.
type FilterURIOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingURIIterator

	Fortastaking012Result *fortastaking012.FortaStakingURIIterator
}

// FilterURI multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterURI(opts *bind.FilterOpts, id []*big.Int) (retVal *FilterURIOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterURIOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterURI(opts, id)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterURI(opts, id)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterURI not implemented (tag=%s)", merged.currTag)
	return
}

// WatchURI multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchURI(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingURI, id []*big.Int, sinkAlt17 chan<- *fortastaking012.FortaStakingURI) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchURI(opts, sink, id)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchURI(opts, sinkAlt17, id)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchURI not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingURI is a merged return type.
type FortaStakingURI struct {
	Value string

	Id *big.Int

	Raw types.Log
}

// ParseURI multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseURI(log types.Log) (retVal *FortaStakingURI, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingURI{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseURI(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Value = val.Value

		retVal.Id = val.Id

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseURI(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Value = val.Value

		retVal.Id = val.Id

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseURI not implemented (tag=%s)", merged.currTag)
	return
}

// FilterUpgradedOutput is a merged return type.
type FilterUpgradedOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingUpgradedIterator

	Fortastaking012Result *fortastaking012.FortaStakingUpgradedIterator
}

// FilterUpgraded multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterUpgraded(opts *bind.FilterOpts, implementation []common.Address) (retVal *FilterUpgradedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterUpgradedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterUpgraded(opts, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterUpgraded(opts, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// WatchUpgraded multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchUpgraded(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingUpgraded, implementation []common.Address, sinkAlt18 chan<- *fortastaking012.FortaStakingUpgraded) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchUpgraded(opts, sink, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchUpgraded(opts, sinkAlt18, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingUpgraded is a merged return type.
type FortaStakingUpgraded struct {
	Implementation common.Address

	Raw types.Log
}

// ParseUpgraded multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseUpgraded(log types.Log) (retVal *FortaStakingUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingUpgraded{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// FilterWithdrawalExecutedOutput is a merged return type.
type FilterWithdrawalExecutedOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingWithdrawalExecutedIterator

	Fortastaking012Result *fortastaking012.FortaStakingWithdrawalExecutedIterator
}

// FilterWithdrawalExecuted multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterWithdrawalExecuted(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, account []common.Address) (retVal *FilterWithdrawalExecutedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterWithdrawalExecutedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterWithdrawalExecuted(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterWithdrawalExecuted(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterWithdrawalExecuted not implemented (tag=%s)", merged.currTag)
	return
}

// WatchWithdrawalExecuted multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchWithdrawalExecuted(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingWithdrawalExecuted, subjectType []uint8, subject []*big.Int, account []common.Address, sinkAlt19 chan<- *fortastaking012.FortaStakingWithdrawalExecuted) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchWithdrawalExecuted(opts, sink, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchWithdrawalExecuted(opts, sinkAlt19, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchWithdrawalExecuted not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingWithdrawalExecuted is a merged return type.
type FortaStakingWithdrawalExecuted struct {
	SubjectType uint8

	Subject *big.Int

	Account common.Address

	Raw types.Log
}

// ParseWithdrawalExecuted multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseWithdrawalExecuted(log types.Log) (retVal *FortaStakingWithdrawalExecuted, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingWithdrawalExecuted{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseWithdrawalExecuted(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Account = val.Account

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseWithdrawalExecuted(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Account = val.Account

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseWithdrawalExecuted not implemented (tag=%s)", merged.currTag)
	return
}

// FilterWithdrawalInitiatedOutput is a merged return type.
type FilterWithdrawalInitiatedOutput struct {
	Fortastaking011Result *fortastaking011.FortaStakingWithdrawalInitiatedIterator

	Fortastaking012Result *fortastaking012.FortaStakingWithdrawalInitiatedIterator
}

// FilterWithdrawalInitiated multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterWithdrawalInitiated(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, account []common.Address) (retVal *FilterWithdrawalInitiatedOutput, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FilterWithdrawalInitiatedOutput{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.FilterWithdrawalInitiated(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking011Result = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterWithdrawalInitiated(opts, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Fortastaking012Result = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterWithdrawalInitiated not implemented (tag=%s)", merged.currTag)
	return
}

// WatchWithdrawalInitiated multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchWithdrawalInitiated(opts *bind.WatchOpts, sink chan<- *fortastaking011.FortaStakingWithdrawalInitiated, subjectType []uint8, subject []*big.Int, account []common.Address, sinkAlt20 chan<- *fortastaking012.FortaStakingWithdrawalInitiated) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.WatchWithdrawalInitiated(opts, sink, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchWithdrawalInitiated(opts, sinkAlt20, subjectType, subject, account)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchWithdrawalInitiated not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingWithdrawalInitiated is a merged return type.
type FortaStakingWithdrawalInitiated struct {
	SubjectType uint8

	Subject *big.Int

	Account common.Address

	Deadline uint64

	Raw types.Log
}

// ParseWithdrawalInitiated multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseWithdrawalInitiated(log types.Log) (retVal *FortaStakingWithdrawalInitiated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingWithdrawalInitiated{}

	if merged.currTag == "0.1.1" {
		val, methodErr := merged.typ0.ParseWithdrawalInitiated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Account = val.Account

		retVal.Deadline = val.Deadline

		retVal.Raw = val.Raw

		return
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseWithdrawalInitiated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Account = val.Account

		retVal.Deadline = val.Deadline

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseWithdrawalInitiated not implemented (tag=%s)", merged.currTag)
	return
}

// FilterSlashDelegatorsPercentSet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterSlashDelegatorsPercentSet(opts *bind.FilterOpts) (retVal *fortastaking012.FortaStakingSlashDelegatorsPercentSetIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterSlashDelegatorsPercentSet(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterSlashDelegatorsPercentSet not implemented (tag=%s)", merged.currTag)
	return
}

// WatchSlashDelegatorsPercentSet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchSlashDelegatorsPercentSet(opts *bind.WatchOpts, sink chan<- *fortastaking012.FortaStakingSlashDelegatorsPercentSet) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchSlashDelegatorsPercentSet(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchSlashDelegatorsPercentSet not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingSlashDelegatorsPercentSet is a merged return type.
type FortaStakingSlashDelegatorsPercentSet struct {
	Percent *big.Int

	Raw types.Log
}

// ParseSlashDelegatorsPercentSet multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseSlashDelegatorsPercentSet(log types.Log) (retVal *FortaStakingSlashDelegatorsPercentSet, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingSlashDelegatorsPercentSet{}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseSlashDelegatorsPercentSet(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Percent = val.Percent

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseSlashDelegatorsPercentSet not implemented (tag=%s)", merged.currTag)
	return
}

// FilterStakeHelpersConfigured multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) FilterStakeHelpersConfigured(opts *bind.FilterOpts, subjectGateway []common.Address, allocator []common.Address) (retVal *fortastaking012.FortaStakingStakeHelpersConfiguredIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.FilterStakeHelpersConfigured(opts, subjectGateway, allocator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.FilterStakeHelpersConfigured not implemented (tag=%s)", merged.currTag)
	return
}

// WatchStakeHelpersConfigured multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) WatchStakeHelpersConfigured(opts *bind.WatchOpts, sink chan<- *fortastaking012.FortaStakingStakeHelpersConfigured, subjectGateway []common.Address, allocator []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.WatchStakeHelpersConfigured(opts, sink, subjectGateway, allocator)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.WatchStakeHelpersConfigured not implemented (tag=%s)", merged.currTag)
	return
}

// FortaStakingStakeHelpersConfigured is a merged return type.
type FortaStakingStakeHelpersConfigured struct {
	SubjectGateway common.Address

	Allocator common.Address

	Raw types.Log
}

// ParseStakeHelpersConfigured multiplexes to different implementations of the method.
func (merged *FortaStakingFilterer) ParseStakeHelpersConfigured(log types.Log) (retVal *FortaStakingStakeHelpersConfigured, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &FortaStakingStakeHelpersConfigured{}

	if merged.currTag == "0.1.2" {
		val, methodErr := merged.typ1.ParseStakeHelpersConfigured(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectGateway = val.SubjectGateway

		retVal.Allocator = val.Allocator

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("FortaStakingFilterer.ParseStakeHelpersConfigured not implemented (tag=%s)", merged.currTag)
	return
}
