// Code generated by go-merge-types. DO NOT EDIT.

package contract_rewards_distributor

import (
	import_fmt "fmt"
	import_sync "sync"

	rewardsdistributor010 "github.com/forta-network/forta-core-go/contracts/generated/contract_rewards_distributor_0_1_0"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"

	"github.com/ethereum/go-ethereum/event"

	"github.com/ethereum/go-ethereum/core/types"

	"github.com/ethereum/go-ethereum/common"

	"math/big"
)

// RewardsDistributorFilterer is a new type which can multiplex calls to different implementation types.
type RewardsDistributorFilterer struct {
	typ0 *rewardsdistributor010.RewardsDistributorFilterer

	currTag string
	mu      import_sync.RWMutex
	unsafe  bool // default: false
}

// NewRewardsDistributorFilterer creates a new merged type.
func NewRewardsDistributorFilterer(address common.Address, filterer bind.ContractFilterer) (*RewardsDistributorFilterer, error) {
	var (
		mergedType RewardsDistributorFilterer
		err        error
	)
	mergedType.currTag = "0.1.0"

	mergedType.typ0, err = rewardsdistributor010.NewRewardsDistributorFilterer(address, filterer)
	if err != nil {
		return nil, import_fmt.Errorf("failed to initialize rewardsdistributor010.RewardsDistributorFilterer: %v", err)
	}

	return &mergedType, nil
}

// IsKnownTagForRewardsDistributorFilterer tells if given tag is a known tag.
func IsKnownTagForRewardsDistributorFilterer(tag string) bool {

	if tag == "0.1.0" {
		return true
	}

	return false
}

// Use sets the used implementation to given tag.
func (merged *RewardsDistributorFilterer) Use(tag string) (changed bool) {
	if !merged.unsafe {
		merged.mu.Lock()
		defer merged.mu.Unlock()
	}
	// use the default tag if the provided tag is unknown
	if !IsKnownTagForRewardsDistributorFilterer(tag) {
		tag = "0.1.0"
	}
	changed = merged.currTag != tag
	merged.currTag = tag
	return
}

// Unsafe disables the mutex.
func (merged *RewardsDistributorFilterer) Unsafe() {
	merged.unsafe = true
}

// Safe enables the mutex.
func (merged *RewardsDistributorFilterer) Safe() {
	merged.unsafe = false
}

// FilterAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) FilterAccessManagerUpdated(opts *bind.FilterOpts, newAddressManager []common.Address) (retVal *rewardsdistributor010.RewardsDistributorAccessManagerUpdatedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterAccessManagerUpdated(opts, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.FilterAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// WatchAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) WatchAccessManagerUpdated(opts *bind.WatchOpts, sink chan<- *rewardsdistributor010.RewardsDistributorAccessManagerUpdated, newAddressManager []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchAccessManagerUpdated(opts, sink, newAddressManager)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.WatchAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// RewardsDistributorAccessManagerUpdated is a merged return type.
type RewardsDistributorAccessManagerUpdated struct {
	NewAddressManager common.Address

	Raw types.Log
}

// ParseAccessManagerUpdated multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) ParseAccessManagerUpdated(log types.Log) (retVal *RewardsDistributorAccessManagerUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &RewardsDistributorAccessManagerUpdated{}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseAccessManagerUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.NewAddressManager = val.NewAddressManager

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.ParseAccessManagerUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// FilterAdminChanged multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) FilterAdminChanged(opts *bind.FilterOpts) (retVal *rewardsdistributor010.RewardsDistributorAdminChangedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterAdminChanged(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.FilterAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}

// WatchAdminChanged multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) WatchAdminChanged(opts *bind.WatchOpts, sink chan<- *rewardsdistributor010.RewardsDistributorAdminChanged) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchAdminChanged(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.WatchAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}

// RewardsDistributorAdminChanged is a merged return type.
type RewardsDistributorAdminChanged struct {
	PreviousAdmin common.Address

	NewAdmin common.Address

	Raw types.Log
}

// ParseAdminChanged multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) ParseAdminChanged(log types.Log) (retVal *RewardsDistributorAdminChanged, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &RewardsDistributorAdminChanged{}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseAdminChanged(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.PreviousAdmin = val.PreviousAdmin

		retVal.NewAdmin = val.NewAdmin

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.ParseAdminChanged not implemented (tag=%s)", merged.currTag)
	return
}

// FilterBeaconUpgraded multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) FilterBeaconUpgraded(opts *bind.FilterOpts, beacon []common.Address) (retVal *rewardsdistributor010.RewardsDistributorBeaconUpgradedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterBeaconUpgraded(opts, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.FilterBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// WatchBeaconUpgraded multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) WatchBeaconUpgraded(opts *bind.WatchOpts, sink chan<- *rewardsdistributor010.RewardsDistributorBeaconUpgraded, beacon []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchBeaconUpgraded(opts, sink, beacon)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.WatchBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// RewardsDistributorBeaconUpgraded is a merged return type.
type RewardsDistributorBeaconUpgraded struct {
	Beacon common.Address

	Raw types.Log
}

// ParseBeaconUpgraded multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) ParseBeaconUpgraded(log types.Log) (retVal *RewardsDistributorBeaconUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &RewardsDistributorBeaconUpgraded{}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseBeaconUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Beacon = val.Beacon

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.ParseBeaconUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// FilterClaimedRewards multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) FilterClaimedRewards(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, to []common.Address) (retVal *rewardsdistributor010.RewardsDistributorClaimedRewardsIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterClaimedRewards(opts, subjectType, subject, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.FilterClaimedRewards not implemented (tag=%s)", merged.currTag)
	return
}

// WatchClaimedRewards multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) WatchClaimedRewards(opts *bind.WatchOpts, sink chan<- *rewardsdistributor010.RewardsDistributorClaimedRewards, subjectType []uint8, subject []*big.Int, to []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchClaimedRewards(opts, sink, subjectType, subject, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.WatchClaimedRewards not implemented (tag=%s)", merged.currTag)
	return
}

// RewardsDistributorClaimedRewards is a merged return type.
type RewardsDistributorClaimedRewards struct {
	SubjectType uint8

	Subject *big.Int

	To common.Address

	EpochNumber *big.Int

	Value *big.Int

	Raw types.Log
}

// ParseClaimedRewards multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) ParseClaimedRewards(log types.Log) (retVal *RewardsDistributorClaimedRewards, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &RewardsDistributorClaimedRewards{}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseClaimedRewards(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.To = val.To

		retVal.EpochNumber = val.EpochNumber

		retVal.Value = val.Value

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.ParseClaimedRewards not implemented (tag=%s)", merged.currTag)
	return
}

// FilterDidAccumulateRate multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) FilterDidAccumulateRate(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, staker []common.Address) (retVal *rewardsdistributor010.RewardsDistributorDidAccumulateRateIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterDidAccumulateRate(opts, subjectType, subject, staker)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.FilterDidAccumulateRate not implemented (tag=%s)", merged.currTag)
	return
}

// WatchDidAccumulateRate multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) WatchDidAccumulateRate(opts *bind.WatchOpts, sink chan<- *rewardsdistributor010.RewardsDistributorDidAccumulateRate, subjectType []uint8, subject []*big.Int, staker []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchDidAccumulateRate(opts, sink, subjectType, subject, staker)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.WatchDidAccumulateRate not implemented (tag=%s)", merged.currTag)
	return
}

// RewardsDistributorDidAccumulateRate is a merged return type.
type RewardsDistributorDidAccumulateRate struct {
	SubjectType uint8

	Subject *big.Int

	Staker common.Address

	StakeAmount *big.Int

	SharesAmount *big.Int

	Raw types.Log
}

// ParseDidAccumulateRate multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) ParseDidAccumulateRate(log types.Log) (retVal *RewardsDistributorDidAccumulateRate, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &RewardsDistributorDidAccumulateRate{}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseDidAccumulateRate(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Staker = val.Staker

		retVal.StakeAmount = val.StakeAmount

		retVal.SharesAmount = val.SharesAmount

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.ParseDidAccumulateRate not implemented (tag=%s)", merged.currTag)
	return
}

// FilterDidReduceRate multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) FilterDidReduceRate(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int, staker []common.Address) (retVal *rewardsdistributor010.RewardsDistributorDidReduceRateIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterDidReduceRate(opts, subjectType, subject, staker)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.FilterDidReduceRate not implemented (tag=%s)", merged.currTag)
	return
}

// WatchDidReduceRate multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) WatchDidReduceRate(opts *bind.WatchOpts, sink chan<- *rewardsdistributor010.RewardsDistributorDidReduceRate, subjectType []uint8, subject []*big.Int, staker []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchDidReduceRate(opts, sink, subjectType, subject, staker)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.WatchDidReduceRate not implemented (tag=%s)", merged.currTag)
	return
}

// RewardsDistributorDidReduceRate is a merged return type.
type RewardsDistributorDidReduceRate struct {
	SubjectType uint8

	Subject *big.Int

	Staker common.Address

	StakeAmount *big.Int

	SharesAmount *big.Int

	Raw types.Log
}

// ParseDidReduceRate multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) ParseDidReduceRate(log types.Log) (retVal *RewardsDistributorDidReduceRate, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &RewardsDistributorDidReduceRate{}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseDidReduceRate(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Staker = val.Staker

		retVal.StakeAmount = val.StakeAmount

		retVal.SharesAmount = val.SharesAmount

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.ParseDidReduceRate not implemented (tag=%s)", merged.currTag)
	return
}

// FilterDidTransferRewardShares multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) FilterDidTransferRewardShares(opts *bind.FilterOpts, sharesId []*big.Int, from []common.Address, to []common.Address) (retVal *rewardsdistributor010.RewardsDistributorDidTransferRewardSharesIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterDidTransferRewardShares(opts, sharesId, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.FilterDidTransferRewardShares not implemented (tag=%s)", merged.currTag)
	return
}

// WatchDidTransferRewardShares multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) WatchDidTransferRewardShares(opts *bind.WatchOpts, sink chan<- *rewardsdistributor010.RewardsDistributorDidTransferRewardShares, sharesId []*big.Int, from []common.Address, to []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchDidTransferRewardShares(opts, sink, sharesId, from, to)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.WatchDidTransferRewardShares not implemented (tag=%s)", merged.currTag)
	return
}

// RewardsDistributorDidTransferRewardShares is a merged return type.
type RewardsDistributorDidTransferRewardShares struct {
	SharesId *big.Int

	SubjectType uint8

	From common.Address

	To common.Address

	SharesAmount *big.Int

	Raw types.Log
}

// ParseDidTransferRewardShares multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) ParseDidTransferRewardShares(log types.Log) (retVal *RewardsDistributorDidTransferRewardShares, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &RewardsDistributorDidTransferRewardShares{}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseDidTransferRewardShares(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SharesId = val.SharesId

		retVal.SubjectType = val.SubjectType

		retVal.From = val.From

		retVal.To = val.To

		retVal.SharesAmount = val.SharesAmount

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.ParseDidTransferRewardShares not implemented (tag=%s)", merged.currTag)
	return
}

// FilterInitialized multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) FilterInitialized(opts *bind.FilterOpts) (retVal *rewardsdistributor010.RewardsDistributorInitializedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterInitialized(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.FilterInitialized not implemented (tag=%s)", merged.currTag)
	return
}

// WatchInitialized multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *rewardsdistributor010.RewardsDistributorInitialized) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchInitialized(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.WatchInitialized not implemented (tag=%s)", merged.currTag)
	return
}

// RewardsDistributorInitialized is a merged return type.
type RewardsDistributorInitialized struct {
	Version uint8

	Raw types.Log
}

// ParseInitialized multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) ParseInitialized(log types.Log) (retVal *RewardsDistributorInitialized, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &RewardsDistributorInitialized{}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseInitialized(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Version = val.Version

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.ParseInitialized not implemented (tag=%s)", merged.currTag)
	return
}

// FilterRewarded multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) FilterRewarded(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int) (retVal *rewardsdistributor010.RewardsDistributorRewardedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterRewarded(opts, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.FilterRewarded not implemented (tag=%s)", merged.currTag)
	return
}

// WatchRewarded multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) WatchRewarded(opts *bind.WatchOpts, sink chan<- *rewardsdistributor010.RewardsDistributorRewarded, subjectType []uint8, subject []*big.Int) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchRewarded(opts, sink, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.WatchRewarded not implemented (tag=%s)", merged.currTag)
	return
}

// RewardsDistributorRewarded is a merged return type.
type RewardsDistributorRewarded struct {
	SubjectType uint8

	Subject *big.Int

	Amount *big.Int

	EpochNumber *big.Int

	Raw types.Log
}

// ParseRewarded multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) ParseRewarded(log types.Log) (retVal *RewardsDistributorRewarded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &RewardsDistributorRewarded{}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseRewarded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.Amount = val.Amount

		retVal.EpochNumber = val.EpochNumber

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.ParseRewarded not implemented (tag=%s)", merged.currTag)
	return
}

// FilterRouterUpdated multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) FilterRouterUpdated(opts *bind.FilterOpts, router []common.Address) (retVal *rewardsdistributor010.RewardsDistributorRouterUpdatedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterRouterUpdated(opts, router)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.FilterRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// WatchRouterUpdated multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) WatchRouterUpdated(opts *bind.WatchOpts, sink chan<- *rewardsdistributor010.RewardsDistributorRouterUpdated, router []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchRouterUpdated(opts, sink, router)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.WatchRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// RewardsDistributorRouterUpdated is a merged return type.
type RewardsDistributorRouterUpdated struct {
	Router common.Address

	Raw types.Log
}

// ParseRouterUpdated multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) ParseRouterUpdated(log types.Log) (retVal *RewardsDistributorRouterUpdated, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &RewardsDistributorRouterUpdated{}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseRouterUpdated(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Router = val.Router

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.ParseRouterUpdated not implemented (tag=%s)", merged.currTag)
	return
}

// FilterSetDelegationFee multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) FilterSetDelegationFee(opts *bind.FilterOpts, subjectType []uint8, subject []*big.Int) (retVal *rewardsdistributor010.RewardsDistributorSetDelegationFeeIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterSetDelegationFee(opts, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.FilterSetDelegationFee not implemented (tag=%s)", merged.currTag)
	return
}

// WatchSetDelegationFee multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) WatchSetDelegationFee(opts *bind.WatchOpts, sink chan<- *rewardsdistributor010.RewardsDistributorSetDelegationFee, subjectType []uint8, subject []*big.Int) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchSetDelegationFee(opts, sink, subjectType, subject)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.WatchSetDelegationFee not implemented (tag=%s)", merged.currTag)
	return
}

// RewardsDistributorSetDelegationFee is a merged return type.
type RewardsDistributorSetDelegationFee struct {
	SubjectType uint8

	Subject *big.Int

	EpochNumber *big.Int

	FeeBps *big.Int

	Raw types.Log
}

// ParseSetDelegationFee multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) ParseSetDelegationFee(log types.Log) (retVal *RewardsDistributorSetDelegationFee, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &RewardsDistributorSetDelegationFee{}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseSetDelegationFee(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.SubjectType = val.SubjectType

		retVal.Subject = val.Subject

		retVal.EpochNumber = val.EpochNumber

		retVal.FeeBps = val.FeeBps

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.ParseSetDelegationFee not implemented (tag=%s)", merged.currTag)
	return
}

// FilterSetDelegationParams multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) FilterSetDelegationParams(opts *bind.FilterOpts) (retVal *rewardsdistributor010.RewardsDistributorSetDelegationParamsIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterSetDelegationParams(opts)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.FilterSetDelegationParams not implemented (tag=%s)", merged.currTag)
	return
}

// WatchSetDelegationParams multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) WatchSetDelegationParams(opts *bind.WatchOpts, sink chan<- *rewardsdistributor010.RewardsDistributorSetDelegationParams) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchSetDelegationParams(opts, sink)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.WatchSetDelegationParams not implemented (tag=%s)", merged.currTag)
	return
}

// RewardsDistributorSetDelegationParams is a merged return type.
type RewardsDistributorSetDelegationParams struct {
	EpochDelay *big.Int

	DefaultFeeBps *big.Int

	Raw types.Log
}

// ParseSetDelegationParams multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) ParseSetDelegationParams(log types.Log) (retVal *RewardsDistributorSetDelegationParams, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &RewardsDistributorSetDelegationParams{}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseSetDelegationParams(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.EpochDelay = val.EpochDelay

		retVal.DefaultFeeBps = val.DefaultFeeBps

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.ParseSetDelegationParams not implemented (tag=%s)", merged.currTag)
	return
}

// FilterTokensSwept multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) FilterTokensSwept(opts *bind.FilterOpts, token []common.Address) (retVal *rewardsdistributor010.RewardsDistributorTokensSweptIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterTokensSwept(opts, token)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.FilterTokensSwept not implemented (tag=%s)", merged.currTag)
	return
}

// WatchTokensSwept multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) WatchTokensSwept(opts *bind.WatchOpts, sink chan<- *rewardsdistributor010.RewardsDistributorTokensSwept, token []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchTokensSwept(opts, sink, token)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.WatchTokensSwept not implemented (tag=%s)", merged.currTag)
	return
}

// RewardsDistributorTokensSwept is a merged return type.
type RewardsDistributorTokensSwept struct {
	Token common.Address

	To common.Address

	Amount *big.Int

	Raw types.Log
}

// ParseTokensSwept multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) ParseTokensSwept(log types.Log) (retVal *RewardsDistributorTokensSwept, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &RewardsDistributorTokensSwept{}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseTokensSwept(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Token = val.Token

		retVal.To = val.To

		retVal.Amount = val.Amount

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.ParseTokensSwept not implemented (tag=%s)", merged.currTag)
	return
}

// FilterUpgraded multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) FilterUpgraded(opts *bind.FilterOpts, implementation []common.Address) (retVal *rewardsdistributor010.RewardsDistributorUpgradedIterator, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.FilterUpgraded(opts, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.FilterUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// WatchUpgraded multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) WatchUpgraded(opts *bind.WatchOpts, sink chan<- *rewardsdistributor010.RewardsDistributorUpgraded, implementation []common.Address) (retVal event.Subscription, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.WatchUpgraded(opts, sink, implementation)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal = val

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.WatchUpgraded not implemented (tag=%s)", merged.currTag)
	return
}

// RewardsDistributorUpgraded is a merged return type.
type RewardsDistributorUpgraded struct {
	Implementation common.Address

	Raw types.Log
}

// ParseUpgraded multiplexes to different implementations of the method.
func (merged *RewardsDistributorFilterer) ParseUpgraded(log types.Log) (retVal *RewardsDistributorUpgraded, err error) {
	if !merged.unsafe {
		merged.mu.RLock()
		defer merged.mu.RUnlock()
	}

	retVal = &RewardsDistributorUpgraded{}

	if merged.currTag == "0.1.0" {
		val, methodErr := merged.typ0.ParseUpgraded(log)

		if methodErr != nil {
			err = methodErr
			return
		}

		retVal.Implementation = val.Implementation

		retVal.Raw = val.Raw

		return
	}

	err = import_fmt.Errorf("RewardsDistributorFilterer.ParseUpgraded not implemented (tag=%s)", merged.currTag)
	return
}
